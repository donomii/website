
			<!DOCTYPE html>
			<html lang="en">
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<meta name="color-scheme" content="light dark">
			<link rel="icon" type="image/png" href="data:image/png;base64,">
			<title>code / Common Tail</title>
			<style>
				@media (prefers-color-scheme: dark){
					body {
						background:#000;
						--bg-color: #000;
					}
				}
				body{
					margin:1em auto;
					max-width:40em;
					padding:0 .62em 3.24em;
					font:1.2em/1.62 sans-serif;
					--bg-color: white;
				}
				h1,h2,h3 {
					line-height:1.2
				}
				article h1 {
					margin-left: 0;
					text-align: center;
				}
				.summary {
					text-align: center;
				}
				@media print{
					body{
						max-width:none
					}
				}
				img {
					max-width: 25%;
					height: auto;
					float: left;
					margin: 0 1em 1em 0;
				}
				img.right {
					float: right;
					margin: 0 0 1em 1em;
				}
				article img {
					cursor: pointer;
					transition: opacity 0.2s;
				}
				article img:hover {
					opacity: 0.85;
				}
				.lightbox-overlay {
					display: none;
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background: rgba(0, 0, 0, 0.9);
					z-index: 9999;
					justify-content: center;
					align-items: center;
					cursor: pointer;
				}
				.lightbox-overlay.active {
					display: flex;
				}
				.lightbox-overlay img {
					max-width: 90%;
					max-height: 90%;
					object-fit: contain;
					border-radius: 4px;
					box-shadow: 0 0 30px rgba(0,0,0,0.5);
					float: none;
					margin: 0;
					cursor: default;
				}
				.lightbox-close {
					position: absolute;
					top: 20px;
					right: 30px;
					color: white;
					font-size: 40px;
					font-weight: bold;
					cursor: pointer;
				}
				.lightbox-close:hover {
					color: #ccc;
				}
			</style>
			<article>
			<header>

			<h1>code / Common Tail</h1>
			</header>
			<div class="summary">
<p>Find the common tail of two lists in C, for a job interview</p>
</div>
<div style="clear:both"></div>
<div style="text-align: center; margin: 2em 0;"><span style="display: inline-block; width: 20%; border-top: 2px solid #333; position: relative;"><span style="position: absolute; top: -0.6em; left: 50%; transform: translateX(-50%); background: var(--bg-color, white); padding: 0 0.5em; font-size: 1.5em;">â—†</span></span></div>
<p><a href="../../resources/c_exercises/tree.c">Download</a></p>
<p>I was recently asked to complete some code questions for a job interview.  The first question was worded slightly confusingly, but it involved an ancestor tree, where each leaf node had a pointer to the parent node.  By following the pointers from any leaf, you would eventually end up at the ancestor node for the entire tree.  So exactly the opposite of a normal tree.  In fact, the entire tree is a collection of linked lists with a common tail.</p>
<p>The challenge was to find the first common parent of any two leaf nodes.  What this boils down to is finding the common tail of two linked lists, which is a typical student assignment.  It gets a bit more complicated in C, But then there are also some fun optimisations available in C.  I'll get to that next post.</p>
<p>The standard way to solve this common-tail-of-linked-lists problem is to get the length of both lists, chop the front off the longer list to make both lists the same length, then walk along them comparing the elements pairwise from both lists.  If any of the elements are equal, then the two lists merge, and they have a common tail (and thus the leaves have a common ancestor).</p>
<p>There are some issues with this naive approach, like the fact that getting the length of a linked list requires us to visit every element of the list.  This means we walk along each list twice.  This is a problem for long lists, and it is also not the absolute best solution, which is an important consideration for getting job interviews!</p>
<p>The task also had an extra condition: I couldn't declare any new Classes (the task was actually for java programmers), and I couldn't modify any existing classes.  I interpreted that to mean no new structures in C, and not changing the provided structure, which heavily limited my possible answers.</p>
<p>So here it is, the simple, rather dull way of doing it.  Next up, I make it a bit faster, and much more confusing.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

/*One item in the linked list*/
typedef struct TreeNodeStruct { 
	struct TreeNodeStruct* parent;
} TreeNode;

/*Return the length of the linked list*/
int branchLength ( TreeNode* A) {
	int lengthA;
	for (lengthA=1; A-&gt;parent!=NULL; A=A-&gt;parent) {
		lengthA++;
	}

	return lengthA;
}

/* Move along the linked list by &lt;length&gt; elements */
TreeNode* drop (TreeNode* T, int length) {
	int i;

	for (i=0; i&lt;length; i++) {
		T=T-&gt;parent;
	}

	return T;
}

/* Take two leaf nodes, traverse towards the root node until we find a common node (if any) */
TreeNode* findFirstCommonAncestor (TreeNode* A, TreeNode* B) {
	int lengthA,lengthB, diff;
	TreeNode* C;

	if (!(A&amp;&amp;B)){return NULL;}

	lengthA = branchLength(A);
	lengthB = branchLength(B);
	diff = lengthA-lengthB;

	/*Drop the front of the longest list to make both lists the same length */
	if (diff&gt;=0) {
		A=drop(A,diff);
	} else {
		B=drop(B,-diff);
	}
	
	/* Now compare the lists element by element.  If the elements are the same, we have found the common ancestor */
	for (A=A; A!=NULL; A=A-&gt;parent) {
		if (A==B) { return A;}
		B=B-&gt;parent;
	}
	return NULL;
}

/* Test function: Create a linked list to test our functions on */

TreeNode* makeBranch (TreeNode* parent, int length) {
	int i;
	TreeNode* t;
	TreeNode* prev_t = parent;

	for (i=0;i&lt;length; i++) {
		t = (TreeNode*) calloc(1,sizeof(TreeNode));
		t-&gt;parent = prev_t;
		prev_t=t;
	}
	return t;
}

void test () {

	TreeNode* R = (TreeNode*) calloc(1,sizeof(TreeNode));
	TreeNode* Rbranch = makeBranch(R,200);
	TreeNode* A = makeBranch(NULL, 10);
	TreeNode* B = makeBranch(NULL, 5);
	TreeNode* C = makeBranch(R, 10);
	TreeNode* D = makeBranch(R, 5);
	TreeNode* E = makeBranch(Rbranch, 1000);
	TreeNode* F = makeBranch(Rbranch, 500);

	int i;
	for (i=0; i&lt;1000000; i++) {

		//Check we handle NULL correctly
		TreeNode* res = findFirstCommonAncestor(NULL, NULL);
		assert(res==NULL);
		
		//Check branches from different trees (no common root)
		res = findFirstCommonAncestor(A,B);
		assert(res==NULL);

		//Check branches are separate up to the tree root
		res = findFirstCommonAncestor(C,D);
		assert(res==R);

		//Check degenerate case
		res = findFirstCommonAncestor(R,R);
		assert(res==R);

		//Check a real case
		res = findFirstCommonAncestor(E,F);
		assert(res==Rbranch);

		//Check branchLength(B)&gt;branchLength(A)
		res = findFirstCommonAncestor(F,E);
		assert(res==Rbranch);
	}
}


int main(int argc, char* argv[])
{
		test();
}

</code></pre>

			</article>
			<div class="lightbox-overlay" id="lightbox">
				<span class="lightbox-close" id="lightbox-close">&times;</span>
				<img src="" alt="" id="lightbox-img">
			</div>
			<script>
			(function() {
				var overlay = document.getElementById('lightbox');
				var lightboxImg = document.getElementById('lightbox-img');
				var closeBtn = document.getElementById('lightbox-close');
				
				// Add click handler to all images in the article
				document.querySelectorAll('article img').forEach(function(img) {
					img.addEventListener('click', function(e) {
						e.preventDefault();
						lightboxImg.src = this.src;
						lightboxImg.alt = this.alt;
						overlay.classList.add('active');
					});
				});
				
				// Close on overlay click
				overlay.addEventListener('click', function(e) {
					if (e.target === overlay || e.target === closeBtn) {
						overlay.classList.remove('active');
					}
				});
				
				// Close on escape key
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						overlay.classList.remove('active');
					}
				});
			})();
			</script>
			</html>
			