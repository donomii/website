
			<!DOCTYPE html>
			<html lang="en">
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<meta name="color-scheme" content="light dark">
			<link rel="icon" type="image/png" href="data:image/png;base64,">
			<title>Javascript Ray Marcher v0.3</title>
			<style>
				@media (prefers-color-scheme: dark){
					body {
						background:#000;
						--bg-color: #000;
					}
				}
				body{
					margin:1em auto;
					max-width:40em;
					padding:0 .62em 3.24em;
					font:1.2em/1.62 sans-serif;
					--bg-color: white;
				}
				h1,h2,h3 {
					line-height:1.2
				}
				article h1 {
					margin-left: 0;
					text-align: center;
				}
				.summary {
					text-align: center;
				}
				@media print{
					body{
						max-width:none
					}
				}
				img {
					max-width: 25%;
					height: auto;
					float: left;
					margin: 0 1em 1em 0;
				}
				img.right {
					float: right;
					margin: 0 0 1em 1em;
				}
				article img {
					cursor: pointer;
					transition: opacity 0.2s;
				}
				article img:hover {
					opacity: 0.85;
				}
				.lightbox-overlay {
					display: none;
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background: rgba(0, 0, 0, 0.9);
					z-index: 9999;
					justify-content: center;
					align-items: center;
					cursor: pointer;
				}
				.lightbox-overlay.active {
					display: flex;
				}
				.lightbox-overlay img {
					max-width: 90%;
					max-height: 90%;
					object-fit: contain;
					border-radius: 4px;
					box-shadow: 0 0 30px rgba(0,0,0,0.5);
					float: none;
					margin: 0;
					cursor: default;
				}
				.lightbox-close {
					position: absolute;
					top: 20px;
					right: 30px;
					color: white;
					font-size: 40px;
					font-weight: bold;
					cursor: pointer;
				}
				.lightbox-close:hover {
					color: #ccc;
				}
			</style>
			<article>
			<header>

			<h1>Javascript Ray Marcher v0.3</h1>
			</header>
			<div class="summary">
</div>
<div style="clear:both"></div>
<div style="text-align: center; margin: 2em 0;"><span style="display: inline-block; width: 20%; border-top: 2px solid #333; position: relative;"><span style="position: absolute; top: -0.6em; left: 50%; transform: translateX(-50%); background: var(--bg-color, white); padding: 0 0.5em; font-size: 1.5em;">â—†</span></span></div>
<style type="text/css">
canvas { border: 1px solid black; }
</style>
<script src="jquery-1.3.2.js" type="text/javascript" charset="utf-8"></script>
<script src="Dumper.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
var ctx;
var canvas;
var outWin;
function setup(){
//Graph is a handy wrapper object for dealing with the output window.
outWin = new Graph("canvasdiv");
outWin.erase(ctx);
//sun = new Vector (outWin.width,outWin.height,10);
sun = new Vector (100,100,-5);
//sun = sun.normalise();
	//Kick off the render
	renderImage();
}
var phase=1;
var x = phase;
var y = 1;
function renderImage () {
	//If we try to draw the entire picture in one go, the browser will freeze.  So instead we draw one pixel at a time.
	x+=11;
	if (x>=outWin.width) {
		x=phase;
		y+=1;
		if (y>=outWin.height) {
		   y=1;
		   phase++;
      if(phase>11) {
			//finished
			return;
			alert("Finished");
		}}
	}
	ray = new Ray( x, y );
	intersect = castRay( ray.origin, ray.direction ) ;	
	//The ray object contains the position and direction of the ray.  castRay walks along the ray, looking for terrain.
	if( intersect )
		{ outWin.setPixel(x,y,terrainColour( intersect )); }  //We hit the terrain, draw the ground colour
	else
		{ outWin.setPixel( x, y,  skyColour()); }  //We missed the terrain, draw the sky colour
	//Give the browser some time to do other processing
	setTimeout("renderImage()", 1);
}
//This is the function that sets the shape of the ground.  Simple for now, it will get very complicated soon.
//function ground(x,z) { return 2;}
//function ground(x,z) { ret= 90*Math.sin(x/5)*Math.sin(z/5); return ret; ;}
//function ground(x,z) { ret= 60*Math.sin(x*x+z*z); return ret; ;}
function ground(x,z) { ret= -20*Math.sin(x/20)*Math.sin(z/10); return ret; ;}
//function ground(x,z) { ret= 150-(x-100)*(x-100)/32-z*z; return ret; ;}
//Math.sin(x)*Math.sin(x)+
function castRay(   ro,  rd ) {
     delt = 0.001;
     mint = 0.0001;
     maxt = 100.0;
    //Step along the ray 
    for( t = mint; t < maxt; t += delt )
    {
      delt=delt*1.05;
      p =  jQuery.extend(true, {}, ro);
      dir = jQuery.extend(true, {}, rd);
      dir.mult(t);
      p=p.add(dir);
        if( p.y < ground( p.x, p.z ) ) {
        //We've sunk into the ground. 
            return p;
        }
    }
    return false;
}
//Clumsy attempt at a vector object
function Vector ( xx, yy, zz) {
this.x = xx;
this.y = yy;
this.z = zz;
this.add = function (aVec) {
newx =this.x + aVec.x;
newy =this.y + aVec.y;
newz =this.z + aVec.z;
return new Vector(newx, newy, newz);
}
this.vsub = function (aVec) {
newx =this.x - aVec.x;
newy =this.y - aVec.y;
newz =this.z - aVec.z;
return new Vector(newx, newy, newz);
}
this.mult = function (aScalar) {
this.x = this.x * aScalar;
this.y = this.y * aScalar;
this.z = this.z * aScalar;
}
this.magnitude = function () {
return Math.sqrt( this.x*this.x + this.y*this.y + this.z*this.z);
}
this.normalise = function ( p ) {
newx = this.x/this.magnitude();
newy = this.y/this.magnitude();
newz = this.z/this.magnitude();
return new Vector(newx, newy, newz);
}
this.cross = function ( p ) {
newx = this.y*p.z - this.z*p.y;
newy = this.z*p.x - this.x*p.z;
newz = this.x*p.y - this.y*p.x;
return new Vector(newx, newy, newz);
}
this.innerProduct = function(p) {
res = this.x * p.x + this.y * p.y +  this.z * p.z;
//setDiv('debugdiv',"!!"+res+"!");
ret = res;
return ret;
}
}
//This creates a ray, pointing in the right direction
function Ray (x,y) {
//y=100-y;
this.origin = new Vector (outWin.width/2,outWin.height/4,-1);
offset = new Vector(0,outWin.height/3,0);
this.origin = this.origin.add(offset);
//this.direction = new Vector (0.1,-0.5+y/200,0.1);
this.viewport = new Vector(x,y,0);
this.viewport = this.viewport.add(offset);
this.direction = this.origin.vsub(this.viewport);
this.direction = this.direction.normalise();
this.origin = new Vector (x,y,0);
this.direction = new Vector (0,-0.1,0.1);
this.direction = new Vector (0,-y/100,1);
//setDiv("debugdiv", printVec(this.direction)); 
}
function printVec(v) {
return "" + v.x + ", " + v.y + ", " + v.z;
}
//var sun = new Vector (1,1,0);
var sun;
function terrainColour(p) {
   //p = p.normalise();
   to_sun = p.vsub(sun);
   to_sun = to_sun.normalise();
    n = interpolate_normal(p);
   //t = n.innerProduct(p)
   //t1 = n.mult(2*t);
    //            reflected = p.vsub(n);
   intensity = n.innerProduct(to_sun);
		  if( intensity<0) { intensity=0;}
		  intensity = intensity * 256;
    intensity = 256-intensity;
		  ret = rgb( intensity,intensity,intensity);
		  //if ( intensity<50 ) { ret = rgb(50,50,50)};
//setDiv('debugdiv',"!!"+ret+"!");
		  return ret;
}
function skyColour () { return "#0000FF"}
function interpolate_normal (p) {
eps = 0.01;
xvec = new Vector ( eps,
     ground(p.x, p.z) - ground(p.x + eps, p.z),
     0);
zvec = new Vector ( 0,
     ground(p.x, p.z) - ground(p.x, p.z + eps),
     eps);
    //x=xvec.normalise();
    //z=zvec.normalise();
         n = xvec.cross(zvec); 
		  normal = n.normalise();
//    setDiv('debugdiv', " " + normal.x +", "+ normal.y +", "+ normal.z);
    return normal;
}
function Graph(aCanvas ) {
	this.canvas = document.getElementById('canvasdiv');
	this.width = this.canvas.width;
	this.height = this.canvas.height;
	if (this.canvas.getContext){
		this.ctx = this.canvas.getContext('2d');
	}
	function redraw (somedata, aLength) {
		gr = this.ctx;
		this.erase();
		for ( ii=0;ii<myLength;ii++) {
			if ((currind == ii) && (mode == 'anneal')) {
				gr.fillStyle = "#00FF00";
			} else {
				gr.fillStyle = "#FF0000";
			}
			gr.fillRect( ii, 0, 1, somedata[ii][2] );
		};
	}
	this.redraw=redraw;

	this.setPixel = function (x, yy, aColor) {
		var y =  this.height-yy;
		aCtx = outWin.ctx;
		outWin.ctx.strokeStyle = aColor;
		aCtx.beginPath();
		aCtx.moveTo(x-1,y-1);
		aCtx.lineTo(x,y);
		aCtx.stroke();
	};
	function erase () {
		aCtx = this.ctx;
		aCtx.fillStyle = "#000000";
		aCtx.globalAlpha=1;
		aCtx.strokeStyle ='#FFFFFF';
		aCtx.fillRect( 0, 0, this.canvas.width, this.canvas.height);
	}
	this.erase = erase;
}
function int (x) { return Math.abs(Math.floor(x)) }
function int2hex (x) {
t = x.toString(16);
if (t.length ==1 ) {
t = t + "0";
}
return t;
}
//Pack 3 numbers into the '#ABCDEF' format needed for html
function rgb(red, green, blue)
{
	red = int(red);
	green = int(green);
	blue = int(blue);
	var decColor = int(red) + 256 * int(green) + 65536 * int(blue);
	return '#'+int2hex(red)+int2hex(green)+int2hex(blue);
}
function setDiv(divName, content)
{ document.getElementById(divName).innerHTML = content; ;}
</script>
<p><canvas id="canvasdiv" width="200" height="200"></canvas></p>
<div id="debugdiv"></div>
<div>
<p>Here I have added lighting, giving a much softer render of the landscape.  Diffuse lighting depends entirely on the angle of the light falling on the surface.  If the light is off to one side and landing at a low angle, then the surface will be darker.  We don't take the camera position into account, like we will do when we add specular lighting.  Diffuse surfaces are typically soft materials like fabric, organic materials, dirt etc.</p>
<p>To get the normal, we fire 3 rays into the target.  One is the camera ray. One of the rays is shifted sideways a little, the other is shifted up a little.  The vectors from the impact point to the two extra rays form the the gradient plane of the surface at the impact point, and their cross product is the normal vector that we want.</p>
<p>This is an extension of the previous version, which assumed that there was only a ground function, so we could just check the height of the ground at any point.  However we now have extra shapes, separate from the ground, so we have to do the proper calculations for all of them.</p>
<p>So the render process now works as follows:</p>
<ul>
<li>Find the point where the ray hits something.</li>
<li>Calculate the vector of the surface (the normal) at that impact point</li>
<li>Calculate the vector from the impact point to the sun, and normalise it</li>
<li>Take the dot product of the surface normal and sun vector</li>
<li>Color the point, brightest when the vectors are aligned and the dot product is 1, and darkest when the vectors are perpendicular and the dot product is 0.</li>
</ul>
<p>In the picture below, the bands of colour on the front hills, are actually a mistake in the colouring algorithm.  Initally I thought it was just an issue with the step size that would dissapear when I optimsed the speed and reduced the step size, but in fact it is a fundamental problem in my implementation.  I'm leaving it there as a demonstration of a common bug, or something like that.</p>
<p><img loading="lazy" src="/projects/javascriptraymarcher/ver3.png" alt="Example render"></p>
<script>setup();</script>
			</article>
			<div class="lightbox-overlay" id="lightbox">
				<span class="lightbox-close" id="lightbox-close">&times;</span>
				<img src="" alt="" id="lightbox-img">
			</div>
			<script>
			(function() {
				var overlay = document.getElementById('lightbox');
				var lightboxImg = document.getElementById('lightbox-img');
				var closeBtn = document.getElementById('lightbox-close');
				
				// Add click handler to all images in the article (skip linked images)
				document.querySelectorAll('article img:not(.no-lightbox)').forEach(function(img) {
					img.addEventListener('click', function(e) {
						e.preventDefault();
						lightboxImg.src = this.src;
						lightboxImg.alt = this.alt;
						overlay.classList.add('active');
					});
				});
				
				// Close on any click
				overlay.addEventListener('click', function() {
					overlay.classList.remove('active');
				});
				
				// Close on escape key
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						overlay.classList.remove('active');
					}
				});
			})();
			</script>
			</html>
			