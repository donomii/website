<html>
<head>
<title>Canvas tutorial</title>
<style type="text/css">
canvas { border: 1px solid black; }
</style>
<script src="jquery-1.4.2.js" type="text/javascript" charset="utf-8"></script>
<script src="Dumper.js" type="text/javascript" charset="utf-8"></script>
<script src="test.raw" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">

var up = new Vector(0,1,0);
var PI=3.14159;
var outWin;
var scene_brightness=1.000;
var camera = new Camera();
//camera.rotate(70,0,-30);
//camera.translate(00,20,0);
camera.rotate(60,0,0);
camera.translate(0,0,-200);
//camera.rotate(90,0,0);
//camera.translate(500,0,0);

function setup(){
	//Graph is a handy wrapper object for dealing with the output window.
	outWin = new Graph('canvasdiv');
	outWin.erase();

lights = [
new Light(0, -30, -40, -20, 1000.0,1000.0,1000.0),
//new Light(0, -30, -40, 20, 1000.0,1000.0,1000.0),
new Light(-50, 0, -20, 20, 0,1000.0,0),
new Light(0, -50, -20, 20, 0,0,1000.0),
//new Light(0, 50, -20, 20, 1.0,1.0,1.0),
];
//for (i=0;i<5;i++)
//  { lights[i]=new Light(80*i, 40, -20, 512,0,0)}
  //Kick off the render
	renderImage();
}

function Light ( xx, yy, zz, rr, cr, cg, cb) {
this.x = xx;
this.y = yy;
this.z = zz;
this.rad = rr;
this.r = cr;
this.g = cg;
this.b = cb;
this.colour = new Colour( cr, cg, cb);
this.name = "Light";

this.bounding_sphere = new BoundingSphere(xx,yy,zz,rr);

this.surrounds = 
function (point,direction) { 
if (gen_sphere(this.x, this.y, this.z, point.x,point.y,point.z) < this.rad*this.rad) {
  point.object=this;
  return point;
 } else { return false; }


}

}


var phase=0;
var yphase=0;
var x = phase;
var y = yphase;
function renderImage () {
	//If we try to draw the entire picture in one go, the browser will freeze.  So instead we draw one pixel at a time.
	x+=11;
	if (x>=outWin.width) {	
	  x=phase;
	  y+=11;
	  if (y>=outWin.height) {
	    outWin.update();
	    y=yphase;
	    phase++;
	    if(phase>11) {
	      yphase++;
	      phase=0;
	      if(yphase>11) {
			//finished
	      alert("Finished");
	      return;}}}}
	ray = camera.newray(x,y);
	intersection = castRay( ray.origin, ray.direction ) ;
    
	//The ray object contains the position and direction of the ray.  castRay walks along the ray, looking for terrain.
	if((phase==0) && (yphase==0)) {    
	  outWin.setBox(x,y,calculate_colour(intersection, false));}
	else {
	  outWin.setRawPixel(x,y,calculate_colour(intersection, false));}
	  //Give the browser some time to do other processing
	  setTimeout("renderImage()", 1);
}

function calculate_colour(intersection, reflected) {
  if( intersection ) { 
    return terrainColour( intersection, ray.direction, reflected ); }  //We hit the terrain, draw the ground colour  
  else
   { return skyColour(); }  //We missed the terrain, draw the sky colour
}

//This is the function that sets the shape of the ground.  Simple for now, it will get very complicated soon.
function ground(x,y,z) { return z*2+1;ret=0; if (z>90) { ret=200;};return ret;}
//function ground(x,z) { ret= 90*Math.sin(x/5)*Math.sin(z/5); return ret; ;}
//function ground(x,z) { ret= 60*Math.sin(x*x+z*z); return ret; ;}
//function ground(x,y,z) { ret= 50*Math.sin(x/20)*Math.sin(z/10); return ret; ;}
//function ground(x,z) { ret= 150-(x-100)*(x-100)/32-z*z; return ret; ;}
//Math.sin(x)*Math.sin(x)+
function sphere(x,y,z) { ret = (x-120)*(x-120) + (y-140)*(y-140) + (z-21)*(z-21); return ret; }
function gen_sphere(cx,cy,cz,x,y,z) { ret = (x-cx)*(x-cx) + (y-cy)*(y-cy) + (z-cz)*(z-cz); return ret; }
function sphere2(x,y,z) { ret = (x-100)*(x-100) + (y-50)*(y-50) + (z-21)*(z-21); return ret; }
function sphere3(x,y,z) { ret = (x-180)*(x-180) + (y-70)*(y-70) + (z-21)*(z-21); return ret; }

//function sphere(x,y,z) { ret = (x-50)*(x-50) + (y-100)*(y-100) + (z-21)*(z-21); return ret; }
//function sphere2(x,y,z) { ret = (x-100)*(x-100) + (y-50)*(y-50) + (z-21)*(z-21); return ret; }
//function sphere3(x,y,z) { ret = (x-150)*(x-150) + (y-100)*(y-100) + (z-21)*(z-21); return ret; }

function BoundingSphere ( xx, yy, zz, rr) {
this.x = xx;
this.y = yy;
this.z = zz;
this.center = new Vector(xx,yy,zz);
this.r = rr;
this.name = "BoundingSphere";

this.intersects = 
function (origin, direction) {
var l = direction.normalise();
var c = this.center.vsub(origin);
var d = (l.innerProduct( c))*(l.innerProduct( c)) - this.x*this.x-this.y*this.y-this.z*this.z + this.r*this.r;
if (d>=0) {
   return true;
 } else { return false; }
}

}

function BoundingFunction ( xx, yy, zz, f) {
this.x = xx;
this.y = yy;
this.z = zz;
this.center = new Vector(xx,yy,zz);
this.name = "BoundingFunction";

this.intersects = f;

}

//Objects for display on screen
function Sphere ( xx, yy, zz, rr, cr, cg, cb) {
this.x = xx;
this.y = yy;
this.z = zz;
this.r = rr;
this.colour = new Colour( cr, cg, cb);
this.name = "Sphere";
this.bounding_sphere = new BoundingSphere(xx,yy,zz,rr);

this.surrounds = 
function (point,direction) { 
dist_squared = (this.x-point.x)*(this.x-point.x) + (this.y-point.y)*(this.y-point.y) + (this.z-point.z)*(this.z-point.z);
if (this.r*this.r>dist_squared) {
   point.object=this;
  return point;
 } else { return false; }
}

}
function PointCloud ( xx, yy, zz, rr, cr, cg, cb) {
this.x = xx;
this.y = yy;
this.z = zz;
this.r = rr;
this.scale = 2;
this.colour = new Colour( cr, cg, cb);
this.name = "PointCloud";

this.surrounds = 
function (point,direction) {
var iii=false;
for (iii=0;iii<myPoints.length;iii=iii+3){
vertexx = myPoints[iii]*this.scale; 
vertexy = myPoints[iii+1]*this.scale;
vertexz = myPoints[iii+2]*this.scale;
dist_squared = (this.x-point.x+vertexx)*(this.x-point.x+vertexx) + (this.y-point.y+vertexy)*(this.y-point.y+vertexy) + (this.z-point.z+vertexz)*(this.z-point.z+vertexz);
if (this.r*this.r>dist_squared) {
   point.object=this;
  return point;
 }}
return false; 
}

}
function sameSide(p1,p2,a,b) {
BA = b.vsub(a);
cp1 = BA.cross(p1.vsub(a));
cp2 = BA.cross(p2.vsub(a));
if (cp1.innerProduct(cp2)>=0) {return true;} else {return false;}
}

function inTriangle(point,A,B,C) {
if(
sameSide(point, A,B,C) && 
sameSide(point, B, A, C) && 
sameSide(point,C,A,B)
){return true;}else{return false} 
}


function BoundingTriangle ( x1, y1, z1, x2, y2, z2, x3, y3 ,z3) {
this.v0 = new Vector(x1,y1,z1);
this.v1 = new Vector(x2,y2,z2);
this.v2 = new Vector(x3,y3,z3);
this.name = "BoundingTriangle";

this.intersects = 
function (origin, direction) {
	var e1,e2,h,s,q;
	var a,f,u,v;
	
	e1=this.v1.vsub(this.v0);
	e2=this.v2.vsub(this.v0);
	h= direction.cross(e2);
	a = e1.innerProduct(h);
	
	if (a > -0.00001 && a < 0.00001)
		return false;
	
	f = 1/a;
	s=origin.vsub(this.v0);
	u = f * (s.innerProduct(h));
	
	if (u < 0.0 || u > 1.0)
		return false;
	
	q=s.cross(e1);
	v = f * direction.innerProduct(q);
	if (v < 0.0 || u + v > 1.0)
		return false ;
	// at this stage we can compute t to find out where 
	// the intersection point is on the line
	var t = f * e2.innerProduct(q);

	if (t > 0.00001) // ray intersection
		return true ;
	else // this means that there is a line intersection  
		 // but not a ray intersection
		 return false;


}

}

function Triangle ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, cr, cg, cb) {
this.x = x1;
this.y = y1;
this.z = z1;
this.A = new Vector(x1,y1,z1);
this.B = new Vector(x2,y2,z2);
this.C = new Vector(x3,y3,z3);
var n = this.C.cross(this.B);
var N = n.normalise();
N = N.smult(2);
this.D = this.A.add(N);
this.bounding_sphere = new BoundingTriangle( x1, y1, z1, x2,y2,z2, x3,y3,z3);//new BoundingSphere((x1+x2+x3)/3,(y1+y2+y3)/3,(z1+z2+z3)/3,(this.A.vsub(this.B)).magnitude());

//new Triangle(0,0,20 ,30,0,20, 0,30,20, 10, 1.0,1.0,1.0),
// A = 0,0,20
//B = 30,0,20
//C = 0,30,20
//D = 10,0,20
this.colour = new Colour( cr, cg, cb);
this.name = "Triangle";

this.surrounds = 
function (origin, direction) {
	var e1,e2,h,s,q;
	var a,f,u,v;
	
	e1=this.B.vsub(this.A);
	e2=this.C.vsub(this.A);
	h= direction.cross(e2);
	a = e1.innerProduct(h);
	
	if (a > -0.00001 && a < 0.00001)
		return false;
	
	f = 1/a;
	s=origin.vsub(this.A);
	u = f * (s.innerProduct(h));
	
	if (u < 0.0 || u > 1.0)
		return false;
	
	q=s.cross(e1);
	v = f * direction.innerProduct(q);
	if (v < 0.0 || u + v > 1.0)
		return false ;
	// at this stage we can compute t to find out where 
	// the intersection point is on the line
	var t = f * e2.innerProduct(q);
//setDiv('debugdiv', "t: " + t); 

	if ((t > 0.00001) &&( t <1.0)) // ray intersection
		{origin.object = this;return origin;}
	else // this means that there is a line intersection  
		 // but not a ray intersection
		 {return false;}


}

}


function Tetrahedron ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, cr, cg, cb) {
this.x = x1;
this.y = y1;
this.z = z1;
this.A = new Vector(x1,y1,z1);
this.B = new Vector(x2,y2,z2);
this.C = new Vector(x3,y3,z3);
var n = this.C.cross(this.B);
var N = n.normalise();
N = N.smult(2);
this.D = this.A.add(N);
this.bounding_sphere = new BoundingSphere((x1+x2+x3)/3,(y1+y2+y3)/3,(z1+z2+z3)/3,(this.A.vsub(this.B)).magnitude());

//new Triangle(0,0,20 ,30,0,20, 0,30,20, 10, 1.0,1.0,1.0),
// A = 0,0,20
//B = 30,0,20
//C = 0,30,20
//D = 10,0,20
this.colour = new Colour( cr, cg, cb);
this.name = "Tetrahedron";

this.surrounds = 
function (point) {
//setDiv('debugdiv', "D: " + this.D); 
if(
inTriangle(point,this.A,this.B,this.D)&&
 inTriangle(point,this.A,this.B,this.C) &&
inTriangle(point,this.A,this.D,this.C) &&

inTriangle(point,this.D,this.B,this.C) 
){ point.object = this;return point}
else {return false;}
}

}



function Colour ( rr, gg, bb) {
this.r = rr;
this.g = gg;
this.b = bb;
this.darken = function () {
this.r = this.r*0.9;
this.g = this.g*0.9;
this.b = this.b*0.9; 
}

}
function Terrain ( xx, yy, zz, rr, cr, cg, cb) {
this.colour = new Colour( cr, cg, cb);
this.name = "Terrain";
this.bounding_sphere = new BoundingFunction(0,0,0,function (origin, direction) {return true;if (origin.z>30){origin.object=this;return origin;}    else { return false; }});

this.surrounds = function (point, direction) { 
if (point.z>30){point.object=this;return point;}
else{return false;}
}
}
function Square ( xx, yy, zz, rr, cr, cg, cb) {
this.x = xx;
this.y = yy;
this.z = zz;
this.r = rr;
this.colour = new Colour( cr, cg, cb);
this.name = "Cube";

this.surrounds = 
function (point,direction) { 
xdis = (this.x-point.x)*(this.x-point.x);
ydis = (this.y-point.y)*(this.y-point.y);
zdis = (this.z-point.z)*(this.z-point.z);
if (this.r*this.r>xdis) {
if (this.r*this.r>ydis) {
if (this.r*this.r>zdis) {
  point.object=this;
  return point;
 }}}
return false;
}

}

function Grid ( xx, yy, zz, rr) {
this.x = xx;
this.y = yy;
this.z = zz;
this.r = rr;
this.scale = 1/rr;
this.sphere = new Sphere(xx,yy,zz,rr);
this.name = "Mandelbrot";

this.surrounds = function (point,direction) { 
for(ix=-2;ix<3;ix++){
for(iy=-2;iy<3;iy++){
 tx = (point.x-this.x+ix*100)*this.scale;
 ty = (point.y-this.y+iy*100)*this.scale;
 tz = (point.z-this.z)*this.scale;
// if(this.sphere.surrounds(point)) {
   if(in_mandelbrot(tx,ty,tz)) { 
   point.object=this;
   return point;}
//   }
 }
}
return false;
}
}


function Mandelbrot ( xx, yy, zz, rr, cr, cg, cb) {
this.x = xx;
this.y = yy;
this.z = zz;
this.r = rr;
this.scale = 1/rr;
this.colour = new Colour( cr, cg, cb);
this.sphere = new Sphere(xx,yy,zz,rr);
this.name = "Mandelbrot";

this.surrounds = function (point,direction) { 
tx = (point.x-this.x)*this.scale;
ty = (point.y-this.y)*this.scale;
tz = (point.z-this.z)*this.scale;

if(this.sphere.surrounds(point,direction)) {
lv = new Vector(tx,ty,tz);
lv.rotateY(45*PI/180);
if (lv.z*lv.z<0.1) {
  if(in_mandelbrot(lv.x,lv.y,lv.z)) { 
  point.object=this;
  return point;} else { return false;}
  }
}
return false;
}
}

objects = [
new Terrain(1,2,3,4,1.0,1.0,1.0),
//new Sphere(0  ,-50,-21,10,1,1,1),
//new Sphere(-10,-70,-21,10,1,1,1),
//new Sphere(10 ,-100,-21,10,1,1,1),
//new Sphere( 0,0,21,10),
//new Mandelbrot(0,-30,21,30, 1.0, 1.0, 1.0),
//new PointCloud(0,-30,0,1, 1.0, 1.0, 1.0),
//new Triangle(0,0,20,30,0,20,0,30,20,10,1.0,1.0,1.0),
//new Sphere(30,30,21,10),
//new Sphere(-30,-30,21,10,1,0,0),
//new Square(-30,30,21,10),
//new Square(30,-30,21,10,0,1,0),
//new Square(40,40,21,10)
//new Sphere(150,100,21,20),
//new Grid(100,100,10,20)
//new Sphere(100,100,10,20)
];

for (iii=0;iii<myPoints.length;iii=iii+9){
objects.push(new Triangle(myPoints[iii+0],myPoints[iii+1],myPoints[iii+2],myPoints[iii+3],myPoints[iii+4],myPoints[iii+5],myPoints[iii+6],myPoints[iii+7],myPoints[iii+8],10,1.0,1.0,1.0));
}
//objects = objects.slice(0,40);
//function chatter (message) {setDiv("debugdiv",message);sleep(50)}
function chatter(message) {}
 function sleep(naptime){
	var sleeping = true;
        var now = new Date();
        var alarm;
        var startingMSeconds = now.getTime();
        alert("starting nap at timestamp: " + startingMSeconds + "\nWill sleep for: " + naptime + " ms");
        while(sleeping){
            alarm = new Date();
            alarmMSeconds = alarm.getTime();
            if(alarmMSeconds - startingMSeconds > naptime){ sleeping = false; }
        }        
        alert("Wakeup!");
    }
function castRay(   ro,  rd ) {
     var delt = 0.1;
     var mint = 0.0001;
     var maxt = 100.0;
     var maxdelt = 1;
    //Step along the ray 
    var last = ro
chatter( "Casting ray " + x + ", " + y + " with xphase, yphase: " + phase +", "+ yphase);
var candidates = [];
//Check if we hit a bounding sphere
// If we don't, we can leave early
hitbounds = true;
var ii=false;
      for(ii=0;ii<objects.length;ii++){
        if (objects[ii].bounding_sphere.intersects(ro,rd)) {
           candidates.push(objects[ii]);hitbounds = true;}
        }
for(ii=0;ii<lights.length;ii++){
        if (lights[ii].bounding_sphere.intersects(ro,rd)) {hitbounds = true;}
       }
if (!hitbounds ) {
//setDiv('debugdiv',"Bailed early");
return false}
//setDiv('debugdiv',"Did not bail - "+candidates.length+" candidates");
var tt = false;
    for( tt = mint; tt < maxt; tt += delt )
    {
chatter(" t is: " + tt);
      //delt=delt*1.01;
      if (delt>maxdelt){delt=maxdelt}
      //p =  jQuery.extend(true, {}, ro);
      //dir = jQuery.extend(true, {}, rd);
      var dir = rd.smult(tt);
      var p=ro.add(dir);

      if (isHit(p,rd, candidates)) {var h = bifurcation(last,p,10,candidates);
//setDiv('debugdiv',"!!" + h.toString() + " is halfway between " + last.toString() + " and " + p.toString() + "!");
p.x=h.x;p.y=h.y;p.z=h.z;return p;}      
      last = p;
//        if( p.y < ground( p.x, 0, p.z ) ) {
//       //We've sunk into the ground. 
//            return p;
//        }
    }
    return false;
}


function isHit (p,direction, candidates) {
chatter("isHit("+p+","+direction+",);");
//Check for impact with a light.   
var ii=false;     
      for(ii=0;ii<lights.length;ii++){
        if (lights[ii].surrounds(p,direction)) {return p;}
        }

//Otherwise check if we have hit an object
      for(ii=0;ii<candidates.length;ii++){
        if (candidates[ii].surrounds(p,direction)) {return p;}
        }
return false;

}

function findHalfWay(a,b){
chatter("findHalfWay("+a+","+b+",);");
var c = b.vsub(a);
var d = c.smult(0.5);
var e = a.add(d);
//setDiv('debugdiv',"!!" + e.toString() + " e");
return e;
}
function bifurcation (a,b, count, candidates) {
chatter("bifurcation("+a+", "+b+", "+count+");");
var direction = b.vsub(a);
if (count>0) {
var h = findHalfWay(a, b);
if (isHit(h,direction, candidates)) {
return bifurcation(a,h, count-1,candidates);}
else{
return bifurcation(h,b, count-1,candidates);
}
}
return findHalfWay(a,b);
}

//Clumsy attempt at a vector object
function Vector ( xx, yy, zz) {
this.x = xx;
this.y = yy;
this.z = zz;
this.object="uninited";

this.add = function (aVec) {
newx =this.x + aVec.x;
newy =this.y + aVec.y;
newz =this.z + aVec.z;
return new Vector(newx, newy, newz);
}

this.vsub = function (aVec) {
newx = this.x - aVec.x;
newy = this.y - aVec.y;
newz = this.z - aVec.z;
return new Vector(newx, newy, newz);
}

this.mult = function (aScalar) {
this.x = this.x * aScalar;
this.y = this.y * aScalar;
this.z = this.z * aScalar;
}
this.smult = function (aScalar) {
newx = this.x * aScalar;
newy = this.y * aScalar;
newz = this.z * aScalar;
return new Vector(newx, newy, newz);
}

this.vmult = function (aVec) {
newx = this.x * aVec.x;
newy = this.y * aVec.y;
newz = this.z * aVec.z;
return new Vector(newx, newy, newz);
}

this.magnitude = function () {
return Math.sqrt( this.x*this.x + this.y*this.y + this.z*this.z);
}

this.normalise = function ( p ) {
newx = this.x/this.magnitude();
newy = this.y/this.magnitude();
newz = this.z/this.magnitude();
return new Vector(newx, newy, newz);
}

this.cross = function ( p ) {
newx = this.y*p.z - this.z*p.y;
newy = this.z*p.x - this.x*p.z;
newz = this.x*p.y - this.y*p.x;
return new Vector(newx, newy, newz);
}

this.innerProduct = function(p) {
var res = this.x * p.x + this.y * p.y +  this.z * p.z;
//setDiv('debugdiv',"!!"+res+"!");
return res;
}
this.toString = function() {
return "x: " + this.x + "  y: " + this.y + "  z: " + this.z ; 
}

this.clone = function() {
var ret = new Vector(this.x, this.y, this.z);
return ret;
}

this.rotateZ = function(q) {
nx = this.x*Math.cos(q) - this.y*Math.sin(q);
ny = this.x*Math.sin(q) + this.y*Math.cos(q);
nz = this.z;
this.x = nx; this.y = ny; this.z = nz;
}


this.rotateY = function(q) {
nx = this.z*Math.sin(q) + this.x*Math.cos(q);
ny = this.y;
nz = this.z*Math.cos(q) - this.x*Math.sin(q);
this.x = nx; this.y = ny; this.z = nz;
}


this.rotateX = function(q) {
nx = this.x;
ny = this.y*Math.cos(q) - this.z*Math.sin(q)
nz = this.y*Math.sin(q) + this.z*Math.cos(q)
this.x = nx; this.y = ny; this.z = nz;
}

}

//This creates a ray, pointing in the right direction



function Camera () {
this.x = 0;
this.y = 0;
this.z = 0;
this.xrot = 0;
this.yrot = 0;
this.zrot = 0;

this.translate = function (dx, dy, dz) {
this.x = this.x + dx;
this.y = this.y + dy;
this.z = this.z + dz;
}

this.rotate = function (dx, dy, dz) {
this.xrot = this.xrot + dx;
this.yrot = this.yrot + dy;
this.zrot = this.zrot + dz;
}
this.newray = function (px, py) {
var aRay = new Ray(x,y);

	aRay.origin.rotateX(this.xrot*PI/180);
        aRay.direction.rotateX(this.xrot*PI/180);
	aRay.origin.rotateY(this.yrot*PI/180);
        aRay.direction.rotateY(this.yrot*PI/180);
	aRay.origin.rotateZ(this.zrot*PI/180);
        aRay.direction.rotateZ(this.zrot*PI/180);
return aRay;
}
}

function Ray (x,y) {
//y=100-y;


//this.origin = new Vector (outWin.width/2,outWin.height/4,-1);
//offset = new Vector(0,outWin.height/3,0);
//this.origin = this.origin.add(offset);


//this.direction = new Vector (0.1,-0.5+y/200,0.1);


//this.viewport = new Vector(x,y,0);
//this.viewport = this.viewport.add(offset);
//this.direction = this.origin.vsub(this.viewport);
//this.direction = this.direction.normalise();
//this.origin = new Vector (x/2,y/2,0);
//b = new Vector(0,0,-50);
//this.origin = this.origin.add(b);
//this.direction = new Vector (0,0,1);
//(-25 -> 0), (-25 -> 0)
this.origin = new Vector (0,0, -40);
this.viewport = new Vector(x/8*400/outWin.width-12.5,y/8*400/outWin.width-12.5,-14);
//this.direction = this.origin.vsub(this.viewport);
this.direction = this.viewport.vsub(this.origin);
this.direction = this.direction.normalise();
this.origin = this.viewport; 
//setDiv('debugdiv', "direction: " + this.direction.toString());

//this.direction = new Vector (0,-y/100,1);
//setDiv("debugdiv", printVec(this.direction)); 

}

function printVec(v) {
return "" + v.x + ", " + v.y + ", " + v.z;
}




function normalColour(p, direction) {
   to_sun = p.vsub(sun);
   to_sun = to_sun.normalise();
    n = interpolate_normal(p, direction);
    n.mult(256);
    n.x=int(n.x);
    n.y=int(n.y);
    n.z=int(n.z);
//  setDiv('debugdiv',"!!"+n.toString()+"!");
     var ret = new Colour(n.x,n.y,n.z);
     return ret;   
}

function terrainColour(p, direction, reflected) {
   var hit=p.clone();
   
   var n = interpolate_normal(p, direction);
  
   var red=0;var green=0;var blue=0;
//Fire a ray towards each light.  If we hit a light, this point is illuminated by that light.
//The combination of all the lights is the colour we draw.
//Later we will add colours to the objects, these will be calculated here as well.
var i;
for(i=0;i<lights.length;i++) {
    var l = lights[i];
    var h = hit.clone();
    var m = new Vector(h.x, h.y, h.z); 
   m = m.vsub(direction);
  m = m.vsub(direction);
  //setDiv('debugdiv', "Checking light " +i+ " at " + lights[i].x);
     var to_light = m.vsub(l);
   to_light = to_light.normalise();
   //to_light.mult(0.01);  
   
   var md = new Vector(to_light.x, to_light.y, to_light.z);
   md.mult(-1);
   var see_light = castRay(m, md);
  //setDiv('debugdiv', "Hit light " + see_moon);
if (see_light) {
      if (see_light.object==l) {
      var distance = p.vsub(l);
      distance = distance.magnitude();
//setDiv('debugdiv',"!! distance "+distance+"!");

//distance=1;
//      n = interpolate_normal(h, direction);
//        intensity = n.innerProduct(to_light)/distance;

var intensity = 1/distance/distance;
//setDiv('debugdiv',"!! intensity "+intensity+"!");

        //if (intensity<0) {intensity=0} 
//intensity=1;
//setDiv('debugdiv',"!!object "+p.object.name+"!");
        red=red+intensity*l.r*p.object.colour.r; 
//setDiv('debugdiv',"!! red "+intensity+"!");

green=green+intensity*l.g*p.object.colour.g;
blue=blue+intensity*l.b*p.object.colour.b;
         //setDiv('debugdiv', "Added colour"); 

}}
  }
//Reflected light
if(!reflected){
//if (false){
if(p.object.name=="Terrain"){
//setDiv('debugdiv',"!! match "+p.object+"!");
//The last attempt:

//avec = n.cross(direction);
//reflected = direction.cross(avec);

//And it actually should have been:

//avec = n.cross(direction);
//reflected = avec.cross(n);

var a = direction.innerProduct(n);
var b = n.smult(a);
var c = b.smult(2);
var reflected_ray = direction.vsub(c);

var aHit = castRay(m, reflected_ray);

var col =  calculate_colour(aHit, reflected_ray, true);
col.darken();
col.darken();
return col;
}
 
}
     return new Colour(red*scene_brightness, green*scene_brightness, blue*scene_brightness);
		
}

function skyColour () { return new Colour(0,0,1);}

function interpolate_normal (hit, direction) {
var eps = 1;
var p = hit;
var qo = new Vector(p.x, p.y-eps, p.z);
var ro = new Vector(p.x, p.y, p.z+eps);

var ey = new Vector ( 0, 1, 0);
var ez = new Vector ( 0, 0, 1);
var crossy = Math.abs(ey.cross(p));
var crossz = Math.abs(ez.cross(p));

if (crossy>0.6) {
qo = new Vector(p.x+eps, p.y, p.z);
ro = new Vector(p.x, p.y, p.z+eps);
}

if (crossz>0.6) {
qo = new Vector(p.x+eps, p.y, p.z);
ro = new Vector(p.x, p.y+eps, p.z);
}

//no = new Vector(p.x, p.y, p.z);
  //nd = jQuery.extend(true, {}, direction);
  //no = no.vsub(nd);
  //no = no.vsub(nd);
  //nd.mult(0.1);
  //n = castRay(no, nd);
    var n = hit;

//qo = new Vector(p.x, p.y-eps, p.z);
  var qd = jQuery.extend(true, {}, direction);
  qo = qo.vsub(qd);
  qo = qo.vsub(qd);
  qd.mult(0.1);
  var q = castRay(qo, qd);


//ro = new Vector(p.x, p.y, p.z+eps);
  var rd = jQuery.extend(true, {}, direction);
  ro = ro.vsub(rd);
  ro = ro.vsub(rd);
  rd.mult(0.1);
  var r = castRay(ro, rd);
  

    var xvec = new Vector ( n.x - q.x, n.y - q.y, n.z - q.z);
    var zvec = new Vector ( n.x - r.x, n.y - r.y, n.z - r.z);
    xvec=xvec.normalise();
    zvec=zvec.normalise();
    var ret = xvec.cross(zvec); 
    ret = ret.normalise();
   
//    setDiv('debugdiv', " " + normal.x +", "+ normal.y +", "+ normal.z);
    return ret;
}

function Graph(aCanvas ) {
	this.canvas = document.getElementById('canvasdiv');
	this.width = this.canvas.width;
	this.height = this.canvas.height;
	if (this.canvas.getContext){
		this.ctx = this.canvas.getContext('2d');
	}
	this.imageData = this.ctx.createImageData(this.width, this.height);
	this.setRawPixel = function (x, y, aColour) {
	  index = (x + y * this.imageData.width) * 4;
	  this.imageData.data[index+0] = aColour.r*256;
	  this.imageData.data[index+1] = aColour.g*256;
	  this.imageData.data[index+2] = aColour.b*256;
	  this.imageData.data[index+3] = 256; //aColour.a;
	  //this.ctx.putImageData(this.imageData, 0, 0);
}
	this.update = function () {this.ctx.putImageData(this.imageData, 0, 0);}
	function redraw (somedata, aLength) {
		gr = this.ctx;
		this.erase();
		var ii = false;
		for ( ii=0;ii<myLength;ii++) {
			if ((currind == ii) && (mode == 'anneal')) {
				gr.fillStyle = "#00FF00";
			} else {
				gr.fillStyle = "#FF0000";
			}
			gr.fillRect( ii, 0, 1, somedata[ii][2] );
		};
	}
	this.redraw=redraw;

	this.setPixel = function (x, yy, aColor) {
		var y =  yy;
		aCtx = outWin.ctx;
		outWin.ctx.strokeStyle = rgb(aColor);
		aCtx.beginPath();
		aCtx.moveTo(x-1,y-1);
		aCtx.lineTo(x,y);
		aCtx.stroke();

	};
  this.setLine = function (x, yy, aColor) {
		var y =  yy;
		aCtx = outWin.ctx;
		outWin.ctx.strokeStyle = aColor;
		aCtx.beginPath();
   aCtx.moveTo(x-5,y-5);
   aCtx.lineTo(x+5,y+5);
		aCtx.stroke();
	};
  this.setBox = function (x, yy, aColor) {
		var y =  yy;
		aCtx = outWin.ctx;
		outWin.ctx.strokeStyle = rgb(aColor);
   aCtx.beginPath();
var ii=false;
   for(ii=0;ii<11;ii++){ 
   aCtx.moveTo(x,y+ii);
   aCtx.lineTo(x+10,y+ii);}
		aCtx.stroke();
	};


	function erase () {
		aCtx = this.ctx;
		aCtx.fillStyle = "#000000";
		aCtx.globalAlpha=1;
		aCtx.strokeStyle ='#FFFFFF';
		aCtx.fillRect( 0, 0, this.canvas.width, this.canvas.height);
	}
	this.erase = erase;
}




function int (x) { return Math.abs(Math.floor(x)) }
function int2hex (x) {
var t = x.toString(16);
if (t.length ==1 ) {
t = "0" + t ;
}
return t;
}
//Pack 3 numbers into the '#ABCDEF' format needed for html
function rgb(aCol)
{
  var red = aCol.r*255;
var blue = aCol.b*255;
var green = aCol.g*255;
  if(red>254){red=254;}
  if(blue>254){blue=254;}
  if(green>254){green=254;}
//  blue=int(blue);
//  green=int(green);
  
  var decColor = int(red) + 256 * int(green) + 65536 * int(blue);
  var ret = '#'+int2hex(int(red))+int2hex(int(green))+int2hex(int(blue));
//  setDiv('debugdiv', "ret: " + ret); 
  return ret; 
}


function setDiv(divName, content)
{ document.getElementById(divName).innerHTML = content; ;}

function in_mandelbrot (x, y, z) {
  x0 = x-0.3;
  y0 = y;

  x = 0;
  y = 0;

  iteration = 0;
  max_iteration = 1000;

  while ( (x*x + y*y <= (2*2)) && ( iteration < max_iteration) )  {
    xtemp = x*x - y*y + x0;
    y = 2*x*y + y0;

    x = xtemp;

    iteration = iteration + 1;
  }

  if ( iteration == max_iteration ) { return true;}
  return false;
  
}


</script>
</head>
<body onload="setup();">
<canvas id="canvasdiv" width="200" height="200"></canvas>
<div id="debugdiv"></div>
<div>
Cleanup time.  I've added Javsacript objects to hold the raytracer objects.  Now all the properties for the objects are in the same place, and adding new ones is much easier.

A few changes to the display routine means it should now do a low-res pass across the whole picture before filling in the details.

Added rotation to vectors, and the code to rotate the camera.
</div>
</body>
</html>
