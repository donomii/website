
			<!DOCTYPE html>
			<html lang="en">
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<meta name="color-scheme" content="light dark">
			<link rel="icon" type="image/png" href="data:image/png;base64,">
			<title>Javascript Ray Marcher v0.15</title>
			<style>
				@media (prefers-color-scheme: dark){
					body {
						background:#000;
						--bg-color: #000;
					}
				}
				body{
					margin:1em auto;
					max-width:40em;
					padding:0 .62em 3.24em;
					font:1.2em/1.62 sans-serif;
					--bg-color: white;
				}
				h1,h2,h3 {
					line-height:1.2
				}
				article h1 {
					margin-left: 0;
					text-align: center;
				}
				.summary {
					text-align: center;
				}
				@media print{
					body{
						max-width:none
					}
				}
				img {
					max-width: 25%;
					height: auto;
					float: left;
					margin: 0 1em 1em 0;
				}
				img.right {
					float: right;
					margin: 0 0 1em 1em;
				}
				article img {
					cursor: pointer;
					transition: opacity 0.2s;
				}
				article img:hover {
					opacity: 0.85;
				}
				.lightbox-overlay {
					display: none;
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background: rgba(0, 0, 0, 0.9);
					z-index: 9999;
					justify-content: center;
					align-items: center;
					cursor: pointer;
				}
				.lightbox-overlay.active {
					display: flex;
				}
				.lightbox-overlay img {
					max-width: 90%;
					max-height: 90%;
					object-fit: contain;
					border-radius: 4px;
					box-shadow: 0 0 30px rgba(0,0,0,0.5);
					float: none;
					margin: 0;
					cursor: default;
				}
				.lightbox-close {
					position: absolute;
					top: 20px;
					right: 30px;
					color: white;
					font-size: 40px;
					font-weight: bold;
					cursor: pointer;
				}
				.lightbox-close:hover {
					color: #ccc;
				}
			</style>
			<article>
			<header>

			<h1>Javascript Ray Marcher v0.15</h1>
			</header>
			<div class="summary">
</div>
<div style="clear:both"></div>
<div style="text-align: center; margin: 2em 0;"><span style="display: inline-block; width: 20%; border-top: 2px solid #333; position: relative;"><span style="position: absolute; top: -0.6em; left: 50%; transform: translateX(-50%); background: var(--bg-color, white); padding: 0 0.5em; font-size: 1.5em;">â—†</span></span></div>
<style type="text/css">
canvas { border: 1px solid black; }
</style>
<script src="jquery.js" type="text/javascript" charset="utf-8"></script>
<script src="Dumper.js" type="text/javascript" charset="utf-8"></script>
<script src="test.raw" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
// Start rendering after the page has fully loaded
window.addEventListener('load', function() {
	setup();
});

//+X is down
//+Y is right
//+X is out of the screen

//Camera is a 0,0,10, aiming at 0,0,0

var up = new Vector(0,1,0);
var PI=3.14159;
var outWin;
var scene_brightness=1.000;  //Scale all the lights by this
var objects = [];
var hits;
var depths;
var progress_count=0;
var stop=false;
var early_bailouts = 0;


/*
   Function: setup

   Creates the lights and objects arrays, creates and fills out the global config, then kicks off the render routine.

   Parameters:

      None

   Returns:

*/

function stop() {
	stop=true;
}

function setup(){
	clearTimeout(renderImage, 1);
	config = new Config();
	//Graph is a handy wrapper object for dealing with the output window.
	outWin = new Graph('canvasdiv');
	outWin.erase();
	timeWin = new Graph('timediv');
	timeWin.erase();
	normalWin = new Graph('normaldiv');
	normalWin.erase();
      
    hits = createArray(outWin.width+101,outWin.height+101);
    depths = createArray(outWin.width+101,outWin.height+101);

	lights = [
		new Light(0, 5, 0, 1.5, 1.0,1.0,1.0),
	];

	config.camera.translate(0,0,10);
	config.camera.target = new Vector(0,0,0)
	config.step = 0.1;
	config.startRay = 0.1;
	config.finishRay = 100.0;
	var confInput = document.getElementById('configTextBox').value;
	objects = eval (confInput);




	setDiv("config", dumpProps(config, "config")+dumpProps(objects, "objects"));
	//setDiv("config", dumpProps(objects, "objects"));
	config.phase=0;
	config.yphase=0;
	config.x = config.phase;
	config.y = config.yphase;
    //Kick off the render
	renderImage();
}


function createArray(length) {
	var arr = new Array(length || 0),
	i = length;

	if (arguments.length > 1) {
		var args = Array.prototype.slice.call(arguments, 1);
		while(i--) arr[length-1 - i] = createArray.apply(this, args);
	}

	return arr;
}



function progress () {
	progress_count++;
	//setDiv('debugdiv',"!! progress: "+ progress_count+"!");
}
	
function dumpProps (obj, prefix) {
	var confString = "";
	for(var prop in obj) {
		if(obj.hasOwnProperty(prop))
			confString += prefix + "." + prop + " : " + obj[prop] + "<br/>" ;
		if (typeof(obj[prop])=="object") { 
			confString += dumpProps(obj[prop], prefix + "." +prop);
		} 
	}
	return confString;
}

/*
   Function: Config

   Creates and returns a global config object

   The object contains default values for rendering the scene, such as the step size, bisection limits and similar config
   
   
   Parameters:

      None

   Returns:

      Config object

   See Also:

      <floodFill>
*/
function Config () {
	this.tracer = false;//  "smoke";
	this.camera = new Camera();
	this.x = 0;
	this.y = 0;
	this.hitCount = 0;
	this.bisection_bailout_threshold = 0.001;
	this.bisection_max_iterations = 20;
	this.smoke_thickness=5;
}

function Light ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.rad = rr;
	this.r = cr;
	this.g = cg;
	this.b = cb;
	this.power = 1.0;
	this.colour = new Colour( cr, cg, cb);
	this.name = "Light";
	this.bounding_sphere = new BoundingSphere(xx,yy,zz,rr);

	this.surrounds = 
	function (point,direction) { 
			if (gen_sphere(this.x, this.y, this.z, point.x,point.y,point.z) < this.rad*this.rad) {
			point.object=this;
			return point;
		} 
		else { 
			return false; 
		}
	}
}


/*
   Function: floodFill

   Experimental routine to improve render speed.
   
   floodFill attempts to render the sureface of an object quickly, by starting the depth search at the same point as a neighbouring point that has already been rendered.  By recursing this, we should be able to render each object straight into the depth buffer without having to step rays out from the camera to the object.
   
   Unfortunately, it doesn't work yet.

   Parameters:

      x - Render coodinates
      y - Render coodinates
      count - The number of recursions left before we return control
      depth_hint - Start the search at this depth

   Returns:

      A colour vector

*/

function floodFill (x, y, count, depth_hint ) {
	//setDiv('debugdiv',"!!starting floodfill at "+x+", "+y+", count " + count + ", depth hint "+depth_hint+"!");
	//sleep(100);
	if (x<1) {return false;}
	if (x>outWin.width) {return false;}
	if (y<1) {return false;}
	if (y>outWin.height) {return false;}
	if (count<0) {return false;}
	if(!depth_hint) {return false;}
	var intersection=false;
	var oldcx = config.x;
	var oldcy = config.y;
	
	var nx = x;
	var ny = y;
	config.x = nx;
	config.y = ny;
	if (!hits[x][y]) {
		var ray = config.camera.newray(nx, ny);
		intersection = castRayWithCandidates(objects, ray.origin, ray.direction, nx , ny, depth_hint);
		colour = calculate_colour(intersection, ray, false);
		outWin.setRawPixel(nx,ny,colour);
		outWin.update();
	}

	if (hits[x][y]) {
		progress();
		var inti, intj;
		var ox=x;
		var oy=y;
		for (inti=-1; inti < 2; inti++) {
			for (intj=-1; intj < 2; intj++) {
				var nx = x + inti; 
				var ny = y + intj; 

				if (nx>1) {
					if (ny>1) {
						config.x = nx;
						config.y = ny;
						if (!hits[nx][ny]){
							//if ((inti != 0) || (intj != 0) ) { floodFill(config.x, config.y, count -1, depths[ox][oy]);}
							if ((inti != 0) || (intj != 0) ) { floodFill(config.x, config.y, count -1, intersection.depth);}
						}
						ox=nx;
						oy=ny;
					}
				}
			}
		}
	}
	config.x = oldcx;
	config.y = oldcy;
}

var doPredict=false;

/*
   Function: renderImage

   Render one pixel in the output image, then set a timeout to call itself in 1 millisecond and return.

   Parameters:

      None

   Returns:

      Nothing, but does a setTimeout to call itself again

   See Also:

      <floodFill>
*/

function renderImage () {
	//If we try to draw the entire picture in one go, the browser will freeze.  So instead we draw one pixel at a time.
	//setDiv('debugdiv',"!!"+depths+"!");
	if(doPredict) {
	doPredict=false;
	var ii=false;
      for(ii=0;ii<objects.length;ii++){
      //alert(new Vector(objects[ii].x,objects[ii].y,objects[ii].z));
      var s = config.camera.findXY(new Vector(objects[ii].x,objects[ii].y,objects[ii].z));
      //alert(s);
      floodFill(s[0], 
      s[1], 
      5, 
      0.1 );
      }}
	config.x+=11;
	if (config.x>=outWin.width) {	
	  config.x=config.phase;
	  config.y+=11;
	  if (config.y>=outWin.height) {
	    
	    //setDiv('debugdiv', "hits: " + config.hitCount);
	    config.hitCount=0;
	    outWin.update();
	    timeWin.update();
	    normalWin.update();
	    config.y=config.yphase;
	    config.phase=(config.phase+3)%13;
	    
	    if(config.phase==0) {
	      config.yphase=(config.yphase+7)%11;
	      config.phase=0;
	      if(config.yphase==0) {
			//finished
	      alert("Finished");
	      return;}}}}
	      
	      if(hits[config.x][config.y]) {
	    if (!stop) {setTimeout(renderImage, 1);}
	    return;
	    }
	var ray = config.camera.newray(config.x,config.y);
	var start = new Date();
	var colour = false;
	if (config.tracer=="smoke"){
	 colour = transRay( ray.origin, ray.direction ) ;
	} else {
	var intersection = castRayWithCandidates( objects, ray.origin, ray.direction, config.x , config.y ) ;
	
	colour = calculate_colour(intersection, ray, false);
	//if (intersection) { floodFill(config.x, config.y, 5, 0.1);}
	}
	var end = new Date();
	var elapsed = end - start;
	timeColour = new Colour ((Math.log(elapsed)-1)/5,0,0);
	//The ray object contains the position and direction of the ray.  castRay walks along the ray, looking for terrain.
	if((config.phase==0) && (config.yphase==0)) {    
	  outWin.setBox(config.x,config.y,colour);
	  timeWin.setBox(config.x,config.y,timeColour);
	  outWin.setRawPixel(config.x,config.y,colour);
	  timeWin.setRawPixel(config.x,config.y,timeColour);
	  }

	  else {
	  outWin.setRawPixel(config.x,config.y,colour);
	  timeWin.setRawPixel(config.x,config.y,timeColour);}
	  //Give the browser some time to do other processing
	  setTimeout("renderImage()", 1);
}

/*
   Function: calculate_colour

   Colour the output pixel

   Parameters:

      intersection - The location in the scene where the ray hit a surface
      ray - The ray, at the point where it hit the surface
      reflected - Has this ray already been reflected? (true/false)  FIXME we should replace this with a count of the number of times it bounced. 

   Returns:

      A colour vector

*/

function calculate_colour(intersection, ray, reflected) {
	//setDiv('debugdiv', "intersection: " + intersection); 
	if( intersection ) { 
		return terrainColour( intersection, ray.direction, reflected ); }  //We hit the terrain, draw the ground colour  
	else
		{ return skyColour(); }  //We missed the terrain, draw the sky colour
}

/* Returns the squared distance from a point to the center of the sphere */
function gen_sphere(cx,cy,cz,x,y,z) { ret = (x-cx)*(x-cx) + (y-cy)*(y-cy) + (z-cz)*(z-cz); return ret; }

/* Creates a bounding sphere object centered on (xx,yy,zz) with radius rr */
function BoundingSphere ( xx, yy, zz, rr) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.center = new Vector(xx,yy,zz);
	this.r = rr;
	this.name = "BoundingSphere";

	this.intersects = 
	function (origin, direction) {
		var l = direction.normalise();
		var c = this.center.vsub(origin);
		var d = (l.innerProduct( c))*(l.innerProduct( c)) - this.x*this.x-this.y*this.y-this.z*this.z + this.r*this.r;

		if (d>=0) {
			return true;
		} 
		else { 
			return false; 
		}
	}

}


/*
   Function: BoundingFunction

   Manages the bounding sphere or other bounding shape.
   
   Bounding spheres speed up raytracing by allowing the raytracer to skip expensive calculations (e.g. for a Mandelbrot primitive).  If the ray is outside the bounding sphere, then the raytracer does not do the Mandelbrot calculation.  Once the ray is inside the bounding sphere, then the raytracer starts doing the full calculation.
   
   This object allows any primitive to be used as a bounding sphere, so e.g. a cube can be used if it is a more efficient shape.

   Parameters:

      xx - The coordinates of the bounding function
      yy - The coordinates of the bounding function
      zz - The coordinates of the bounding function

   Returns:

      A BoundingFunction object

   See Also:

      <TrueBounds>
*/
function BoundingFunction ( xx, yy, zz, f) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.center = new Vector(xx,yy,zz);
	this.name = "BoundingFunction";

	this.intersects = f;
}

/*
   Function: TrueBounds
   
   Bounding spheres speed up raytracing by allowing the raytracer to skip expensive calculations (e.g. for a Mandelbrot primitive).  If the ray is outside the bounding sphere, then the raytracer does not do the Mandelbrot calculation.  Once the ray is inside the bounding sphere, then the raytracer starts doing the full calculation.
   
   This object always forces the enclosed primitive to be calculated, no matter where the ray is (it doesn't speed up the calculations at all).  Normally used for simple shapes (there is no reason to put a bounding sphere around a sphere object).

   Parameters:

      xx - The coordinates of the bounding function
      yy - The coordinates of the bounding function
      zz - The coordinates of the bounding function

   Returns:

      A BoundingFunction object

   See Also:

      <BoundingFunction>
*/

function TrueBounds () {
	this.x = 0;
	this.y = 0;
	this.z = 0;
	this.center = new Vector(0,0,0);
	this.name = "TrueBounds";

	this.intersects = function (a,b) {return true};
}


/*
   Function: Sphere

   Draws a sphere

   Parameters:

      xx - The coordinates of the sphere
      yy - The coordinates of the sphere
      zz - The coordinates of the sphere
      rr - The radius of the sphere
      cr - Red component (0.0 -> 1.0)
      cg - Green component (0.0 -> 1.0)
      cb - Blue component (0.0 -> 1.0)

   Returns:

      A BoundingFunction object

   See Also:

      <Sphere, Cylinder, BlobCylinder, Lsystem>
*/

function Sphere ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.centre = new Vector(xx,yy,zz);
	this.r = rr;
	this.colour = new Colour( cr, cg, cb);
	this.name = "Sphere";
	this.bounding_sphere = new BoundingSphere(xx,yy,zz,rr);

	this.surrounds = 
	function (point,direction) { 
		dist_vec = this.centre.vsub(point);
		dist = dist_vec.magnitude();
		if (this.r>dist) {
			point.object=this;
			return point;
		}
		return false;
	}
}


/*
   Function: RotateYObj

   Rotates another object around a Y-axis

   Parameters:

      xx - The coordinates of the rotation axis
      yy - The coordinates of the rotation axis
      zz - The coordinates of the rotation axis
      rr - The angle, in degrees, to rotate
      oo - The target object to rotate

   Returns:

      A BoundingFunction object

   See Also:

      <Sphere, Cylinder, BlobCylinder, Lsystem, etc>
*/

function RotateYObj ( xx, yy, zz, rr, oo) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.centre = new Vector(xx,yy,zz);
	this.r = rr/180*PI;
	this.name = "RotateYObj";
	this.child = oo;
	this.bounding_sphere = new TrueBounds();  //FIXME

	this.surrounds = 
	function (point,direction) { 
		point.rotateY(this.r);
		return this.child.surrounds(point,direction);
	}
}



/*
   Function: BlobCylinder

   Draws a cylinder with rounded ends

   Parameters:

      startvec - A vector pointing to one end of the cylinder
      endvec - A vector pointing to the other end of the cylinder
      rr - Radius of cylinder
      cr - Red component (0.0 -> 1.0)
      cg - Green component (0.0 -> 1.0)
      cb - Blue component (0.0 -> 1.0)

   Returns:

      A BoundingFunction object

   See Also:

      <Sphere, Cylinder, BlobCylinder, Lsystem>
*/

function BlobCylinder (startvec, endvec, rr, cr, cg, cb ) {
	this.start = startvec;
	this.end = endvec;
	this.colour = new Colour( cr, cg, cb);
	this.name = "Blob";
	this.bounding_sphere = new BoundingSphere(startvec.x, startvec.y, startvec.z,5);
	this.points = [];
	var v = false;
	var rad = rr;
	this.diff = this.end.vsub(this.start);
	this.step = this.diff.smult(0.2);
	for(v=this.start;this.start.vsub(v).magnitude()<this.diff.magnitude();v=v.add(this.step)) {
		this.points.push(new Vector(v.x, v.y, v.z));
	}
	
	this.surrounds = 
		function (point,direction) {
			var p = point; 
			var v = false;
			var potential = 0;
			for(v=0;v<this.points.length;v++){
				var vdist = p.vsub(this.points[v]);
				var dist = vdist.magnitude();
				potential += 1.0/dist/dist;
			}

			if (potential>1) {
				point.object=this;
				return point;
			} else { 
				return false; 
			}
		}

}

/*
   Function: Cylinder

   Draws a cylinder

   Parameters:

      startvec - A vector pointing to one end of the cylinder
      endvec - A vector pointing to the other end of the cylinder
      rr - Radius of cylinder
      cr - Red component (0.0 -> 1.0)
      cg - Green component (0.0 -> 1.0)
      cb - Blue component (0.0 -> 1.0)

   Returns:

      A BoundingFunction object

   See Also:

      <Sphere, Cylinder, BlobCylinder, Lsystem>
*/

function Cylinder ( startvec, endvec, rr, cr, cg, cb) {
	this.end1 = startvec;
	this.end2 = endvec;
	this.r = rr;
	this.colour = new Colour( cr, cg, cb);
	this.name = "Cylinder";
	var temp = this.end1.vsub(this.end2);
	this.len = temp.magnitude();
	this.bounding_sphere = new BoundingSphere(startvec.xx,startvec.yy,startvec.zz,this.len);  //FIXME
	
	this.surrounds = 
	function (point,direction) { 
		var norm1 = this.end2.vsub(this.end1);
		norm1 = norm1.normalise();
		
		var norm2 = norm1.smult(-1);
		
		var dist1 = point.vsub(this.end1);
		dist1 = dist1.innerProduct(norm1);
		
		var dist2 = point.vsub(this.end2);
		dist2 = dist2.innerProduct(norm2);
		
		if (dist1 < 0 )	{return false};	
		if (dist2 < 0) {return false}; 
		var t =  point.vsub(norm1.smult(dist1));
		var centerdist = t.vsub(this.end1);
		if (centerdist.magnitude() > this.r) {return false};
		point.object=this;	
		return point; // All tests passed, point is in cylinder
	}
}

/*
   Function: Lsystem

   Draws a Lindenmeyer system

   Parameters:

      Needs to be updated to have parameters

   Returns:

      A Lsystem object

   See Also:
   
      <Sphere, Cylinder, BlobCylinder, Lsystem>
*/

function Lsystem () {
	this.seed = ["T"];
	this.tree = this.seed;
	this.rules = [];
	this.rules["T"] = ["F", "H", "F", "[", "S",  "R", "T", "]", "[", "S",  "r", "T", "]", "[", "S",  "Z", "T", "]", "[", "S",  "z", "T", "]"];
	this.rules["H"] = ["H"];
	this.rules["Z"] = ["Z"];
	this.rules["z"] = ["z"];
	this.rules["R"] = ["R"];
	this.rules["F"]=["F"]
	//this.rules["T"] = ["T"];
	this.rules["S"] = ["S"];
	this.rules["r"] = ["r"];
	this.rules["["] =  ["["];
	this.rules["]"] = ["]"];
	this.stack = [];
	this.bounding_sphere = new BoundingSphere(0,0,0,1);
	this.objects = [];
	this.recurse = function () {
		var newtree = [];
		var e;
		for (e=0;e<this.tree.length;e++) {
			var replacement = this.rules[this.tree[e]];
			var ee;
			for (ee=0;ee<replacement.length;ee++){
				newtree.push(replacement[ee]);
			}
		}
		this.tree = newtree;
		//setDiv('debugdiv', "tree: " + newtree); 
	};
	this.genobjects = function (oblist) {
		var pos = new Vector(0,0,0);
		var dir = new Vector(0,-2,0);
		var scale = 0.6;
		var thickness = 1;
		for (e=0;e<this.tree.length;e++) {
			var c = this.tree[e];
			if (c == "T") {
				//oblist.push(new Cylinder(pos.x, pos.y, pos.z, pos.x, pos.y+3, pos.z, thickness, 0,1,0));
				oblist.push(new BlobCylinder(pos,new Vector( pos.x, pos.y+3, pos.z)));
			}
			if (c == "F") {
				var aa = false;
				oldpos = pos.smult(1);

				for(aa=0;aa<3;aa++){ 

				//oblist.push(new Sphere(pos.x, pos.y, pos.z, thickness, 1,1,1));
				pos = pos.add(dir);}

				oblist.push(new BlobCylinder(oldpos, pos));
				
				
			}

		if (c == "S") { dir = dir.smult(scale); thickness = thickness *scale }
		if (c == "R") { dir.rotateZ(45*PI/180)}
		if (c == "r") { dir.rotateZ(-45*PI/180)}
		if (c == "Z") { dir.rotateY(45*PI/180)}
		if (c == "z") { dir.rotateY(-45*PI/180)}
		if (c == "[") { this.stack.push(pos.clone());this.stack.push(dir.clone());this.stack.push(thickness);}
		if (c == "]") { thickness = this.stack.pop();dir = this.stack.pop();pos = this.stack.pop();}
		
	}
	};
	this.surrounds = function (point,direction) { 
		var i =0;
		for (i=0;i<this.objects.length;i++){
			var hit = this.objects[i].surrounds(point, direction);
			if (hit) {return hit;}
		}
		return false;
	};
	this.recurse();
	this.recurse();
	this.recurse();
	this.genobjects(this.objects);
	
}


function PointCloud ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.scale = 2;
	this.colour = new Colour( cr, cg, cb);
	this.name = "PointCloud";

	this.surrounds = 
	function (point,direction) {
		var iii=false;
		for (iii=0;iii<myPoints.length;iii=iii+3){
			vertexx = myPoints[iii]*this.scale; 
			vertexy = myPoints[iii+1]*this.scale;
			vertexz = myPoints[iii+2]*this.scale;
			dist_squared = (this.x-point.x+vertexx)*(this.x-point.x+vertexx) + (this.y-point.y+vertexy)*(this.y-point.y+vertexy) + (this.z-point.z+vertexz)*(this.z-point.z+vertexz);
			if (this.r*this.r>dist_squared) {
				point.object=this;
				return point;
			}
		}
		return false; 
	}
}
/* returns true if the vector from a to b is roughly co-planar with p1 and p2
function sameSide(p1,p2,a,b) {
	BA = b.vsub(a);
	cp1 = BA.cross(p1.vsub(a));
	cp2 = BA.cross(p2.vsub(a));
	if (cp1.innerProduct(cp2)>=0) {return true;} else {return false;}
}

/* returns true if the point is inside the triangle defined by A, B, C */
function inTriangle(point,A,B,C) {
	if(
		sameSide(point, A,B,C) &&
		sameSide(point, B, A, C) && 
		sameSide(point,C,A,B)
	) {
		return true;
	}
	else{
		return false;
	} 
}

function BoundingTriangle ( x1, y1, z1, x2, y2, z2, x3, y3 ,z3) {
	this.v0 = new Vector(x1,y1,z1);
	this.v1 = new Vector(x2,y2,z2);
	this.v2 = new Vector(x3,y3,z3);
	this.name = "BoundingTriangle";

	this.intersects = 
	function (origin, direction) {
		var e1,e2,h,s,q;
		var a,f,u,v;
		
		e1=this.v1.vsub(this.v0);
		e2=this.v2.vsub(this.v0);
		h= direction.cross(e2);
		a = e1.innerProduct(h);
		
		if (a > -0.00001 && a < 0.00001)
			return false;
		
		f = 1/a;
		s=origin.vsub(this.v0);
		u = f * (s.innerProduct(h));
		
		if (u < 0.0 || u > 1.0)
			return false;
		
		q=s.cross(e1);
		v = f * direction.innerProduct(q);
		if (v < 0.0 || u + v > 1.0)
			return false ;
		// at this stage we can compute t to find out where 
		// the intersection point is on the line
		var t = f * e2.innerProduct(q);

		if (t > 0.00001) // ray intersection
			return true ;
		else 				// this means that there is a line intersection  
			return false; 	// but not a ray intersection
	}
}

/*
   Function: Triangle

   Draws a triangle
   
   Used mainly for rendering models created for openGL display.  Thickness needs to be larger than  stepsize, or else rays will tend to go through them without hitting.

   Parameters:

      x1, y1, z1 - Corner 1
      x2,y2,z2 - Corner 2
      x3,y3,z3 - Corner 3
      thickness - How thick the triangle is.  Large values result in a triangluar prism
      cr, cg, cb - Colours (in range 0.0 -> 1.0)

   Returns:

      A Triangle object

   See Also:
   
      <Sphere, Cylinder, BlobCylinder, Lsystem, Triangle>
*/

function Triangle ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, cr, cg, cb) {
	this.x = x1;
	this.y = y1;
	this.z = z1;
	this.A = new Vector(x1,y1,z1);
	this.B = new Vector(x2,y2,z2);
	this.C = new Vector(x3,y3,z3);
	var n = this.C.cross(this.B);
	var N = n.normalise();
	N = N.smult(2);
	this.D = this.A.add(N);
	this.bounding_sphere = new BoundingTriangle( x1, y1, z1, x2,y2,z2, x3,y3,z3);//new BoundingSphere((x1+x2+x3)/3,(y1+y2+y3)/3,(z1+z2+z3)/3,(this.A.vsub(this.B)).magnitude());
	//this.bounding_sphere =  new BoundingFunction(0,0,0,function (origin, direction) {return true;});
	//new Triangle(0,0,20 ,30,0,20, 0,30,20, 10, 1.0,1.0,1.0),
	// A = 0,0,20
	//B = 30,0,20
	//C = 0,30,20
	//D = 10,0,20
	this.r = cr;
	this.colour = new Colour( cr, cg, cb);
	this.name = "Triangle";

	this.surrounds = 
	function (origin, direction) {
		oo = origin;
		origin = origin.smult(1);
		var warp_point = new Vector( 5, 5, 0);
		var dist = origin.vsub(warp_point);
		//var shift_vector = dist.smult(1.2/dist.magnitude());
		//origin.rotateZ(5*PI/180);
		var e1,e2,h,s,q;
		var a,f,u,v;
		
		e1=this.B.vsub(this.A);
		e2=this.C.vsub(this.A);
		h= direction.cross(e2);
		a = e1.innerProduct(h);
		
		if (a > -0.00001 && a < 0.00001)
			return false;
		
		f = 1/a;
		s=origin.vsub(this.A);
		u = f * (s.innerProduct(h));
		
		if (u < 0.0 || u > 1.0)
			return false;
		
		q=s.cross(e1);
		v = f * direction.innerProduct(q);
		if (v < 0.0 || u + v > 1.0)
			return false ;
		// at this stage we can compute t to find out where 
		// the intersection point is on the line
		
		var t = f * e2.innerProduct(q);
		//setDiv('debugdiv', "t: " + t); 

		if ((t > 0.00001) &&( t <1.0)) // ray intersection
			{oo.object = this;return oo;}
		else // this means that there is a line intersection  
			// but not a ray intersection
			{return false;}
	}

}

/*
   Function: Tetrahedron

   Draws a tetrahedron, apparently
   
   

   Parameters:

      x1, y1, z1 - Corner 1
      x2,y2,z2 - Corner 2
      x3,y3,z3 - Corner 3
      thickness - How high the tetrahedron is
      cr, cg, cb - Colours (in range 0.0 -> 1.0)

   Returns:

      A Tetrahedron object

   See Also:
   
      <Sphere, Cylinder, BlobCylinder, Lsystem, Triangle, Tetrahedron>
*/


function Tetrahedron ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, cr, cg, cb) {
	this.x = x1;
	this.y = y1;
	this.z = z1;
	this.A = new Vector(x1,y1,z1);
	this.B = new Vector(x2,y2,z2);
	this.C = new Vector(x3,y3,z3);
	var n = this.C.cross(this.B);
	var N = n.normalise();
	N = N.smult(2);
	this.D = this.A.add(N);
	this.bounding_sphere = new BoundingSphere((x1+x2+x3)/3,(y1+y2+y3)/3,(z1+z2+z3)/3,(this.A.vsub(this.B)).magnitude());

	this.colour = new Colour( cr, cg, cb);
	this.name = "Tetrahedron";

	this.surrounds = 
	function (point) {
		//setDiv('debugdiv', "D: " + this.D); 
		if(
			inTriangle(point,this.A,this.B,this.D)&&
			inTriangle(point,this.A,this.B,this.C) &&
			inTriangle(point,this.A,this.D,this.C) &&
			inTriangle(point,this.D,this.B,this.C) 
		){ 
			point.object = this;return point
		} else {
			return false;
		}
	}
}


/*
   Function: Colour

   Creates a colour vector
   
   Contains some methods for manipulating colours

   Parameters:

      rr - Red component
      bb - Green component
      gg - Blue component

   Returns:

      A colour vector

   
*/
function Colour ( rr, gg, bb) {
	this.r = rr;
	this.g = gg;
	this.b = bb;
	this.darken = function (times) {
		var ci;
		for (ci=0;ci<times;ci++) {
			this.r = this.r*0.99;
			this.g = this.g*0.99;
			this.b = this.b*0.99; 
		}
	}
	this.lighten = function () {
	this.r = this.r*1.1;
	this.g = this.g*1.1;
	this.b = this.b*1.1; 
	}


}
function Terrain ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;

	this.colour = new Colour( cr, cg, cb);
	this.name = "Terrain";
	this.bounding_sphere = new TrueBounds();

	this.surrounds = function (point, direction) { 
		if (point.x>this.x){point.object=this;return point;}
		return false;
	}
}

function Cube ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.bounding_sphere = new BoundingSphere(xx,yy,zz,2*rr);
	this.colour = new Colour( cr, cg, cb);
	this.name = "Cube";

	this.surrounds = 
	function (point,direction) { 
		xdis = (this.x-point.x)*(this.x-point.x);
		ydis = (this.y-point.y)*(this.y-point.y);
		zdis = (this.z-point.z)*(this.z-point.z);
		if (this.r*this.r>xdis) {
			if (this.r*this.r>ydis) {
				if (this.r*this.r>zdis) {
					point.object=this;
					return point;
				}
			}
		}
		return false;
	}

}

function Grid ( xx, yy, zz, rr) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.scale = 1/rr;
	this.sphere = new Sphere(xx,yy,zz,rr);
	this.name = "Mandelbrot";

	this.surrounds = function (point,direction) { 
		for(ix=-2;ix<3;ix++){
			for(iy=-2;iy<3;iy++){
				tx = (point.x-this.x+ix*100)*this.scale;
				ty = (point.y-this.y+iy*100)*this.scale;
				tz = (point.z-this.z)*this.scale;
				if(in_mandelbrot(tx,ty,tz)) { 
					point.object=this;
					return point;
				}
			}
		}
		return false;
	}
}


function Mandelbrot ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.scale = 1/rr;
	this.colour = new Colour( cr, cg, cb);
	this.sphere = new Sphere(xx,yy,zz,rr*2);
	this.bounding_sphere = new BoundingSphere(0,0,0,rr*2);
	this.name = "Mandelbrot";

	this.surrounds = function (point,direction) { 
		tx = (point.x-this.x)*this.scale;
		ty = (point.y-this.y)*this.scale;
		tz = (point.z-this.z)*this.scale;

		if(this.sphere.surrounds(point,direction)) {
			lv = new Vector(tx,ty,tz);
			lv.rotateY(45*PI/180);
			lv.rotateX(45*PI/180);
			if (lv.z*lv.z<0.1) {
				if(in_mandelbrot(lv.x,lv.y,lv.z)) { 
					point.object=this;
					return point;
				} 
				else { 
					return false;
				}
			}
		}
		return false;
	}
}

function MandelBulb ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.scale = 2/rr;
	this.colour = new Colour( cr, cg, cb);
	this.bounding_sphere = new BoundingSphere(0,0,0,rr*2);
	this.name = "MandelBulb";

	this.surrounds = function (point,direction) { 
		tx = (point.x-this.x)*this.scale;
		ty = (point.y-this.y)*this.scale;
		tz = (point.z-this.z)*this.scale;


		lv = new Vector(tx,ty,tz);
		lv.rotateX(45*PI/180);
		lv.rotateY(-45*PI/180);
		if(in_mandelquad(lv.x,lv.y,lv.z)) { 
			point.object=this;
			return point;
		} 
		else { 
			return false;
		}
		return false;
	}
}


function Boxthreads ( xx, yy, zz, rr, cr, cg, cb) {
	this.x = xx;
	this.y = yy;
	this.z = zz;
	this.r = rr;
	this.scale = 2/rr;
	this.colour = new Colour( cr, cg, cb);
	this.bounding_sphere = new BoundingSphere(0,0,0,rr*2);
	this.name = "Boxthreads";

	this.surrounds = function (point,direction) { 
		tx = (point.x-this.x)*this.scale;
		ty = (point.y-this.y)*this.scale;
		tz = (point.z-this.z)*this.scale;


		lv = new Vector(tx,ty,tz);
		lv.rotateX(45*PI/180);
		lv.rotateY(-45*PI/180);
		if(in_boxthreads(lv.x,lv.y,lv.z)) { 
			point.object=this;
			return point;
		} 
		else { 
			return false;
		}
		return false;
	}
}

//function chatter (message) {setDiv("debugdiv",message);sleep(50)}
function chatter(message) {}


function sleep(naptime){
	var sleeping = true;
	var now = new Date();
	var alarm;
	var startingMSeconds = now.getTime();
	while(sleeping){
		alarm = new Date();
		alarmMSeconds = alarm.getTime();
		if(alarmMSeconds - startingMSeconds > naptime){ sleeping = false; }
	}        
	//alert("Wakeup!");
}

//lssc_surface_finder
//Here we are given a point in the scene, which should be near a surface, but might be a miss
//we have to figure out where the surface, if any, is

function lssc_surface_finder(   ro,  rd, x , y, depth_hint ) {
// //setDiv('debugdiv',"Starting castRay with x = " + x + "");
     var delt = config.step;
     var mint = config.startRay;
     var maxt = config.finishRay;
     var maxdelt = 2;
     var start_depth=mint;
     if (depth_hint) {
      start_depth = depth_hint;
     }
    

    
    //Step along the ray 
    var last = ro;
	chatter( "Casting ray " + config.x + ", " + config.y + " with xphase, yphase: " + config.phase +", "+ config.yphase);
	var candidates = [];
	//Check if we hit a bounding sphere
	// If we don't, we can leave early
	hitbounds = false;
	var ii=false;
      for(ii=0;ii<objects.length;ii++){
        //if (objects[ii].bounding_sphere.intersects(ro,rd)) {
           candidates.push(objects[ii]);hitbounds = true;}
        //}
	for(ii=0;ii<lights.length;ii++){
        if (lights[ii].bounding_sphere.intersects(ro,rd)) {hitbounds = true;}
       }
	if (!hitbounds ) {
	//setDiv('debugdiv',"Bailed early");
	return false
	}
	//candidates = objects;
	candidates = candidates.concat(lights)
	//setDiv('debugdiv',"Did not bail - "+candidates.length+" candidates");

	//Calculate the current point
	var start_point = ro.add(rd.smult(depth_hint));

	var test_point = ro.add(rd.smult(depth_hint));

	var bailout =5;
	var intersection=false;
	var adjust=1;
	//Are we starting inside the object?
	if (isHit(start_point,rd, candidates)) {
		//Yes we are.  Back up until we can find a point outside
		while ((bailout-->0) && (intersection = isHit(test_point,rd, candidates)) ) {
			test_point = ro.add(rd.smult(depth_hint-5*adjust++));
	}

	var h = bisection(test_point,start_point,config.bisection_max_iterations,[intersection.object].concat(lights));
	setDiv('debugdiv',"!!" + h.toString() + " is halfway between " + last.toString() + " and " + p.toString() + "!");
	start_point.x=h.x;start_point.y=h.y;start_point.z=h.z;
	if (x) {
		hits[x][y] = 1;
		depths[x][y] = (start_point.vsub(ro)).vdiv(rd);
		//depths[x][y].blah = "hello";
		setDiv('debugdiv',"!!Storing depth hint at x =  " +x + ", " + depths[x][y] + "!");
	}
	//isHit(start_point,rd, candidates);
	return start_point;
	}      
  
  


	//otherwise proceed with the cast as usual
	var tt = false;
	var d = new Vector(0,0,0);
	for( tt = start_depth; d.innerProduct(d) < 20*20; tt += delt ) {
		chatter(" t is: " + tt);
		//delt=delt*1.05;
		if (delt>maxdelt){delt=maxdelt}
		//p =  jQuery.extend(true, {}, ro);
		//dir = jQuery.extend(true, {}, rd);
		d = rd.smult(tt);
		var p=ro.add(d);
		//setDiv('debugdiv',"!!" + make_int(p.x) + " "+ make_int(p.y) + " "+ make_int(p.z) + " ");      
		var intersection = isHit(p,rd, candidates)
		if (intersection) {
			config.hitCount++;
			//setDiv('debugdiv',"!!" + x + ", " + y);      


			var h = bisection(last,p,config.bisection_max_iterations,[intersection.object].concat(lights));
			//setDiv('debugdiv',"!!" + h.toString() + " is halfway between " + last.toString() + " and " + p.toString() + "!");
			p.x=h.x;p.y=h.y;p.z=h.z;
			if (x) {
				hits[x][y] = 1;
				depths[x][y] = (p.vsub(ro)).vdiv(rd);
			}
			return p;
		}      
		last = p;
	}
	return false;
}




function castRayWithCandidates(candidates,   ro,  rd, x , y, depth_hint ) {
// //setDiv('debugdiv',"Starting castRay with x = " + x + "");
     var delt = config.step;
     var mint = config.startRay;
     var maxt = config.finishRay;var maxdelt = 2;
     var start_depth=mint;
     if (depth_hint) {
      start_depth = depth_hint;
     }
    

    
    //Step along the ray 
    var last = ro;
	chatter( "Casting ray " + config.x + ", " + config.y + " with xphase, yphase: " + config.phase +", "+ config.yphase);
	//Check if we hit a bounding sphere
	// If we don't, we can leave early
	hitbounds = false;
	var ii=false;
      for(ii=0;ii<candidates.length;ii++){
        if (candidates[ii].bounding_sphere.intersects(ro,rd)) {
           hitbounds = true;}
        }
	if (!hitbounds ) {
	//setDiv('debugdiv',"Bailed early");
	return false
	}
	//setDiv('debugdiv',"Did not bail - "+candidates.length+" candidates");
	var tt = false;
	var d = new Vector(0,0,0);
    for( tt = start_depth; d.innerProduct(d) < 20*20; tt += delt )
    {
	chatter(" t is: " + tt);
      //delt=delt*1.05;
      if (delt>maxdelt){delt=maxdelt}
      //p =  jQuery.extend(true, {}, ro);
      //dir = jQuery.extend(true, {}, rd);
      d = rd.smult(tt);
      var p=ro.add(d);
	//setDiv('debugdiv',"!!" + make_int(p.x) + " "+ make_int(p.y) + " "+ make_int(p.z) + " ");      
	var intersection = isHit(p,rd, candidates)
	if (intersection) {
	config.hitCount++;
	//setDiv('debugdiv',"!!" + x + ", " + y);      
	
	
	var h = bisection(last,p,config.bisection_max_iterations,candidates);
	//setDiv('debugdiv',"!!" + h.toString() + " is halfway between " + last.toString() + " and " + p.toString() + "!");
	p.x=h.x;p.y=h.y;p.z=h.z;p.depth=tt;
	if (x) {
	  hits[x][y] = 1;
	  depths[x][y] = (p.vsub(ro)).vdiv(rd);
	  //depths[x][y].blah = "hello";
	//setDiv('debugdiv',"!!Storing depth hint at x =  " +x + ", " + depths[x][y] + "!");
	  }
	return p;}      
      last = p;
//        if( p.y < ground( p.x, 0, p.z ) ) {
//       //We've sunk into the ground. 
//            return p;
//        }
    }
    return false;
}







function transRay(   ro,  rd ) {
     var delt = config.step;
     var mint = config.startRay;
     var maxt = config.finishRay;
     var maxdelt = 1;
    //Step along the ray 
    var last = ro
chatter( "Casting ray " + config.x + ", " + config.y + " with xphase, yphase: " + config.phase +", "+ config.yphase);
var candidates = [];
//Check if we hit a bounding sphere
// If we don't, we can leave early
hitbounds = false;
var ii=false;
      for(ii=0;ii<objects.length;ii++){
        if (objects[ii].bounding_sphere.intersects(ro,rd)) {
           candidates.push(objects[ii]);hitbounds = true;}
        }
for(ii=0;ii<lights.length;ii++){
        if (lights[ii].bounding_sphere.intersects(ro,rd)) {hitbounds = true;}
       }
if (!hitbounds ) {
//chatter('debugdiv',"Bailed early");
return new Colour(0,0,0);}
//setDiv('debugdiv',"Did not bail - "+candidates.length+" candidates");
var tt = false;
    var col = new Colour(1.0,1.0,1.0);
    for( tt = mint; tt < maxt; tt += delt )
    {
chatter(" t is: " + tt);
      //delt=delt*1.005;
      if (delt>maxdelt){delt=maxdelt}
      //p =  jQuery.extend(true, {}, ro);
      //dir = jQuery.extend(true, {}, rd);
      var dir = rd.smult(tt);
      var p=ro.add(dir);
      
      if (isHit(p,rd, candidates)) {
      col.darken(config.smoke_thickness);}      
      //last = p;
//        if( p.y < ground( p.x, 0, p.z ) ) {
//       //We've sunk into the ground. 
//            return p;
//        }
    }
    return col;
}

/*
   Function: isHit

   Does the actual checks to see if a ray has hit the scene
   

   Parameters:

      p - The position of the ray
      direction - The step vector.  Needed to improve the accuracy of a sufrace hit.
      candidates - A list of scene objects.  surrounds() will be called on each object to see if it "surrounds" the vector.

   Returns:

      An intersection vector

   
*/

function isHit (p,direction, candidates) {
	chatter("isHit("+p+","+direction+",);");
	var ii;     
	
      for(ii=0;ii<candidates.length;ii++){
        if (candidates[ii].surrounds(p,direction)) {return p;}
        }
	return false;
}




function findHalfWay(a,b){
chatter("findHalfWay("+a+","+b+",);");
var c = b.vsub(a);
var d = c.smult(0.5);
var e = a.add(d);
//setDiv('debugdiv',"!!" + e.toString() + " e");
return e;
}
function bisection (a,b, count, candidates) {
chatter("bisection("+a+", "+b+", "+count+");");
var direction = b.vsub(a);
if (direction.innerProduct(direction)< config.bisection_bailout_threshold*config.bisection_bailout_threshold) {
//setDiv('debugdiv',"!!Early bailout at " + count + " iterations, " + early_bailouts++ + " total");
  return a;
  }
if (count>0) {
var h = findHalfWay(a, b);
if (isHit(h,direction, candidates)) {
return bisection(a,h, count-1,candidates);}
else{
return bisection(h,b, count-1,candidates);
}
}
return findHalfWay(a,b);
}

//Clumsy attempt at a vector object
function Vector ( xx, yy, zz) {
this.x = xx;
this.y = yy;
this.z = zz;

this.object="uninited";

this.add = function (aVec) {
newx =this.x + aVec.x;
newy =this.y + aVec.y;
newz =this.z + aVec.z;
return new Vector(newx, newy, newz);
}

this.vsub = function (aVec) {
newx = this.x - aVec.x;
newy = this.y - aVec.y;
newz = this.z - aVec.z;
return new Vector(newx, newy, newz);
}

this.mult = function (aScalar) {
this.x = this.x * aScalar;
this.y = this.y * aScalar;
this.z = this.z * aScalar;
this.calculate_magnitude()
}
this.smult = function (aScalar) {
newx = this.x * aScalar;
newy = this.y * aScalar;
newz = this.z * aScalar;
return new Vector(newx, newy, newz);
}

this.vdiv = function (aVec) {
var res = this.x / aVec.x;
return res;
}

this.vmult = function (aVec) {
newx = this.x * aVec.x;
newy = this.y * aVec.y;
newz = this.z * aVec.z;
return new Vector(newx, newy, newz);
}

this.magnitude = function () {return this.calculate_magnitude()}
this.calculate_magnitude = function () {
this.m = Math.sqrt( this.x*this.x + this.y*this.y + this.z*this.z);
return this.m;
}

this.normalise = function ( p ) {
this.m = this.magnitude();
newx = this.x/this.m;
newy = this.y/this.m;
newz = this.z/this.m;
return new Vector(newx, newy, newz);
}

this.cross = function ( p ) {
newx = this.y*p.z - this.z*p.y;
newy = this.z*p.x - this.x*p.z;
newz = this.x*p.y - this.y*p.x;
return new Vector(newx, newy, newz);
}

this.innerProduct = function(p) {
var res = this.x * p.x + this.y * p.y +  this.z * p.z;
//setDiv('debugdiv',"!!"+res+"!");
return res;
}
this.toString = function() {
return "x: " + this.x + "  y: " + this.y + "  z: " + this.z ; 
}

this.clone = function() {
var ret = new Vector(this.x, this.y, this.z);
return ret;
}

this.rotateZ = function(q) {
var nx = this.x*Math.cos(q) - this.y*Math.sin(q);
var ny = this.x*Math.sin(q) + this.y*Math.cos(q);
var nz = this.z;
this.x = nx; this.y = ny; this.z = nz;
this.calculate_magnitude()
}


this.rotateY = function(q) {
nx = this.z*Math.sin(q) + this.x*Math.cos(q);
ny = this.y;
nz = this.z*Math.cos(q) - this.x*Math.sin(q);
this.x = nx; this.y = ny; this.z = nz;
this.calculate_magnitude()
}


this.rotateX = function(q) {
nx = this.x;
ny = this.y*Math.cos(q) - this.z*Math.sin(q)
nz = this.y*Math.sin(q) + this.z*Math.cos(q)
this.x = nx; this.y = ny; this.z = nz;
this.calculate_magnitude()
}

this.m = this.calculate_magnitude();
}

//This creates a ray, pointing in the right direction



function Camera () {
this.x = 0;
this.y = 0;
this.z = 0;
this.xrot = 0;
this.yrot = 0;
this.zrot = 0;
this.target = new Vector(0,0,0);

this.translate = function (dx, dy, dz) {
this.x = this.x + dx;
this.y = this.y + dy;
this.z = this.z + dz;
}

this.rotate = function (dx, dy, dz) {
this.xrot = this.xrot + dx;
this.yrot = this.yrot + dy;
this.zrot = this.zrot + dz;
}

this.findXY = function (aPoint) {
//alert(aPoint);
var myPosition = new Vector(this.x, this.y, this.z);
var plane = myPosition.normalise();
  //var toPoint = aPoint.vsub(myPosition);
  var toPoint = myPosition.vsub(aPoint);
  //alert(["toPoint",toPoint]);
  //var ldotn = myPosition.smult(-1.0);
  //alert(ldotn);
  var nom = aPoint.innerProduct(plane);
  var denom= toPoint.innerProduct(plane);
  var d = nom/denom;
  //alert(["myPosition",myPosition]);
  var screenPos = aPoint.vsub(toPoint.smult(d));
  var x = screenPos.z;
  var y = screenPos.y;
  //alert(["ScreenPos",screenPos]);
  if (isNaN(x)){x=0;}
  if (isNaN(y)){y=0;}
  return([Math.round(1.0*((x*outWin.width/10+outWin.width/2)-0)), Math.round( 1.0*((y*outWin.height/10+outWin.height/2)-0))]);}

this.newray = function (px, py) {
var aRay = new Ray(px,py, new Vector(this.x, this.y, this.z), this.target);

	/*aRay.origin.rotateX(this.xrot*PI/180);
        aRay.direction.rotateX(this.xrot*PI/180);
	aRay.origin.rotateY(this.yrot*PI/180);
        aRay.direction.rotateY(this.yrot*PI/180);
	aRay.origin.rotateZ(this.zrot*PI/180);
        aRay.direction.rotateZ(this.zrot*PI/180);
*/
	aRay.origin    = aRay.origin.add(new Vector(this.x, this.y, this.z));
        //aRay.direction = aRay.direction.add(new Vector(this.x, this.y, this.z));

return aRay;
}
}

function Ray (x,y, position, target) {
//y=100-y;


//this.origin = new Vector (outWin.width/2,outWin.height/4,-1);
//offset = new Vector(0,outWin.height/3,0);
//this.origin = this.origin.add(offset);


//this.direction = new Vector (0.1,-0.5+y/200,0.1);


//this.viewport = new Vector(x,y,0);
//this.viewport = this.viewport.add(offset);
//this.direction = this.origin.vsub(this.viewport);
//this.direction = this.direction.normalise();
//this.origin = new Vector (x/2,y/2,0);
//b = new Vector(0,0,-50);
//this.origin = this.origin.add(b);
//this.direction = new Vector (0,0,1);
//(-25 -> 0), (-25 -> 0)
/* this.origin = new Vector (0,0, -11);
this.viewport = new Vector((x-outWin.width/2)/outWin.width/2,(y-outWin.height/2)/outWin.height/2,-10);
this.direction = this.origin.vsub(this.viewport);
this.direction = this.viewport.vsub(this.origin);
this.direction = this.direction.normalise();
this.origin = this.viewport; 
*/
//setDiv('debugdiv', "direction: " + this.direction.toString());

//this.direction = new Vector (0,-y/100,1);
//setDiv("debugdiv", printVec(this.direction)); 


this.origin = position;
this.viewport = target.vsub(position);
this.screen = new Vector(10.0*(y-outWin.height/2)/outWin.height,10.0*(x-outWin.width/2)/outWin.width,0.0) ;
this.direction = this.screen.vsub(this.origin);
this.direction = this.direction.normalise();
//this.viewport = position.vsub(target);
//this.viewport.rotateY(2*((x-outWin.width/2)/outWin.width*PI));
//this.viewport.rotateZ(2*((y-outWin.height/2)/outWin.height*PI));
//this.viewport.rotateY(Math.atan((x-outWin.width/2)/outWin.width));
//this.viewport.rotateZ(Math.atan((y-outWin.height/2)/outWin.height));
//this.direction = this.viewport;
//this.viewport.vsub(this.origin);
//this.direction = this.direction.normalise();



}

function printVec(v) {
return "" + v.x + ", " + v.y + ", " + v.z;
}



//FIXME this looks unecessarily complex
function normalColour(norm) {
    var norm = norm.normalise();
    norm = norm.smult(256);
    
    norm.x=make_int((norm.x>0) ? norm.x : -norm.x);
    norm.y=make_int((norm.y>0) ? norm.y : -norm.y);
    norm.z=make_int((norm.z>0) ? norm.z : -norm.z);
//  setDiv('debugdiv',"!!"+n.toString()+"!");
     var ret = new Colour(norm.x/256,norm.y/256,norm.z/256);
     return ret;   
}

//After we calculate the exact location of a hit, we need to colour the surface
//To do this we fire a ray to each light (ouch) to see if the light is shining on this surface
//Then we combine the light's colour with the surface colour, and return that
function terrainColour(p, direction, reflected) {
	var hit=p;
	var n = interpolate_normal(p, direction);
	normalWin.setRawPixel(config.x,config.y, normalColour(n));
	
	var red=0;var green=0;var blue=0;
	//Fire a ray towards each light.  If we hit a light, this point is illuminated by that light.
	//The combination of all the lights is the colour we draw.
	var i;
	for(i=0;i<lights.length;i++) {
		var l = lights[i];
		var m = new Vector(hit.x, hit.y, hit.z); 

		m = m.vsub(direction);
		m = m.vsub(direction);
		var to_light = m.vsub(l);
		to_light = to_light.normalise();
	
	var md = new Vector(to_light.x, to_light.y, to_light.z);
	md.mult(-1);
	var see_light = castRayWithCandidates([l],m, md);
	see_light=true;
	if (see_light) {
		//Check to see if we hit the right light!
		//if (see_light.object==l) {
			var distance = p.vsub(l);
			distance = distance.magnitude();
			//setDiv('debugdiv',"!! distance "+distance+"!");

			var n = interpolate_normal(p, direction);
			if(!reflected){normalWin.setRawPixel(config.x,config.y, normalColour(n));}
			var diffuse_intensity = n.innerProduct(to_light);

			var a = direction.innerProduct(n);
			var b = n.smult(a);
			var c = b.smult(2);
			var reflected_ray = direction.vsub(c);
			var reflected_ray = reflected_ray.normalise();
			var spec_intensity = reflected_ray.innerProduct(to_light);
			spec_intensity = 0;
			var intensity = l.power/distance/distance;
			//setDiv('debugdiv',"!! intensity "+intensity+"!");

			//if (intensity<0) {intensity=0} 
			//intensity=1;
			//setDiv('debugdiv',"!!object "+p.object.name+"!");
			//        red=red+intensity*l.r*p.object.colour.r+intensity*0.2; 
			//green=green+intensity*l.g*p.object.colour.g+intensity*0.2;
			//blue=blue+intensity*l.b*p.object.colour.b+intensity*0.2;

			//setDiv('debugdiv',"!! red "+intensity+"!");
			red = red   
				+ spec_intensity*l.r 
				+ diffuse_intensity*l.r*p.object.colour.r
				+intensity*0.2; 
			green = green 
				+ spec_intensity*l.g 
				+ diffuse_intensity*l.g*p.object.colour.g
				+intensity*0.2;
			blue  = blue  
				+ spec_intensity*l.b + 
				diffuse_intensity*l.b*p.object.colour.b
				+intensity*0.2;
			if (isNaN(red)) {
				console.log("Calculating colour failed!");
				//This sucks, but at least it won't completely kill the rest of the render
				//The show must go on!
				red = 1.0;
				green = 1.0;
				blue = 1.0;
			}
			//setDiv('debugdiv', "Added colour"+ "," + red + "," + green + "," +  blue); 

		}
	}
	//Reflected light
	if(!reflected){
		if(p.object.name=="Terrain"){
			//setDiv('debugdiv',"!! match "+p.object+"!");
			//The last attempt:

			//avec = n.cross(direction);
			//reflected = direction.cross(avec);

			//And it actually should have been:

			//avec = n.cross(direction);
			//reflected = avec.cross(n);
			var n = interpolate_normal(p, direction);
			var a = direction.innerProduct(n);
			var b = n.smult(a);
			var c = b.smult(2);
			var reflected_ray = direction.vsub(c);

			var aHit = castRayWithCandidates(objects,m, reflected_ray);
			//setDiv('debugdiv', "m: "  + " dir: " + reflected_ray.toString());
			var aRay = new Ray(0,0,p,new Vector(0,0,0));
			aRay.direction = reflected_ray;  //Override calculated direction because we know better
			var col =  calculate_colour(aHit, aRay, true);
			col.darken(10);
			col.darken(10);
			col.darken(10);
			return col;
		}
		
	}
	return new Colour(red*scene_brightness, green*scene_brightness, blue*scene_brightness);
			
}

//The default colour if we miss everything
function skyColour () { return new Colour(1,1,1);}

// After we hit the surface, we need to find the "surface normal", a vector pointing straight up from the surface
//Because we don't always have a formula for the surface, we find three points, close together, on the surface,
//calculate the vectors between them, and then take the cross product to get the normal.
function interpolate_normal (hit, direction) {
	var eps = 0.01;
	var p = hit;
	var qo = new Vector(p.x, p.y+eps, p.z);
	var ro = new Vector(p.x, p.y, p.z+eps);

	var ey = new Vector ( 0, 1, 0);
	var ez = new Vector ( 0, 0, 1);
	var doty = Math.abs(ey.innerProduct(direction));
	var dotz = Math.abs(ez.innerProduct(direction));

	if (doty>0.8) {
		qo = new Vector(p.x+eps, p.y, p.z);
		ro = new Vector(p.x, p.y, p.z+eps);
	}

	if (dotz>0.8) {
		qo = new Vector(p.x+eps, p.y, p.z);
		ro = new Vector(p.x, p.y+eps, p.z);
	}
		var n = hit;

	var qd = jQuery.extend(true, {}, direction);
	qo = qo.vsub(qd);
	qo = qo.vsub(qd);
	qd.mult(0.1);
	var q = castRayWithCandidates(objects,qo, qd);

	var rd = jQuery.extend(true, {}, direction);
	ro = ro.vsub(rd);
	ro = ro.vsub(rd);
	rd.mult(0.1);
	var r = castRayWithCandidates(objects,ro, rd);
	

		var xvec = new Vector ( n.x - q.x, n.y - q.y, n.z - q.z);
		var zvec = new Vector ( n.x - r.x, n.y - r.y, n.z - r.z);
		xvec=xvec.normalise();
		zvec=zvec.normalise();
		var ret = xvec.cross(zvec); 
		ret = ret.normalise();
	if (isNaN(ret.x)) {
	console.log(["interpolate_normal failed ",[ret, hit, direction]]);
	ret = new Vector(1,1,1);
	}
	//    setDiv('debugdiv', " " + normal.x +", "+ normal.y +", "+ normal.z);
		return ret;
}

//The main graphics object
function Graph(aCanvasName ) {
	this.canvas = document.getElementById(aCanvasName);
	this.width = this.canvas.width;
	this.height = this.canvas.height;
	if (this.canvas.getContext){
		this.ctx = this.canvas.getContext('2d');
	}
	this.Ctx = this.ctx;
	this.imageData = this.ctx.createImageData(this.width, this.height);
	this.setRawPixel = function (x, y, aColour) {
		index = (x + y * this.imageData.width) * 4;
		this.imageData.data[index+0] = aColour.r*256;
		this.imageData.data[index+1] = aColour.g*256;
		this.imageData.data[index+2] = aColour.b*256;
		this.imageData.data[index+3] = 256; //aColour.a;
		//this.ctx.putImageData(this.imageData, 0, 0);
}
	this.update = function () {this.ctx.putImageData(this.imageData, 0, 0);}
	this.redraw= function (somedata, aLength) {
		gr = this.ctx;
		//this.erase();
		var ii = false;
		for ( ii=0;ii<myLength;ii++) {
			if ((currind == ii) && (mode == 'anneal')) {
				gr.fillStyle = "#00FF00";
			} else {
				gr.fillStyle = "#FF0000";
			}
			gr.fillRect( ii, 0, 1, somedata[ii][2] );
		};
	}
	

	this.setPixel = function (x, yy, aColor) {
		var y =  yy;
		
		this.ctx.strokeStyle = rgb(aColor);
		this.Ctx.beginPath();
		this.Ctx.moveTo(x-1,y-1);
		this.Ctx.lineTo(x,y);
		this.Ctx.stroke();

	};
  this.setLine = function (x, yy, aColor) {
		var y =  yy;
		
		this.ctx.strokeStyle = rgb(aColor);
		this.Ctx.beginPath();
		this.Ctx.moveTo(x-5,y-5);
		this.Ctx.lineTo(x+5,y+5);
		this.Ctx.stroke();
	};
  this.setBox = function (x, yy, aColor) {
		var y =  yy;
		
		this.ctx.strokeStyle = rgb(aColor);
		this.Ctx.fillStyle = rgb(aColor);
		this.Ctx.globalAlpha=1;
		
		this.Ctx.fillRect( x, y, 30, 30);
}


	this.erase = function () {
		this.Ctx = this.ctx;
		this.Ctx.fillStyle = "#000000";
		this.Ctx.globalAlpha=1;
		this.Ctx.strokeStyle ='#FFFFFF';
		this.Ctx.fillRect( 0, 0, this.canvas.width, this.canvas.height);
	}
}




function make_int (x) { return Math.abs(Math.floor(x)) }
function int2hex (x) {
	var t = x.toString(16);
	if (t.length ==1 ) {
		t = "0" + t ;
	}
	return t;
}


//Pack 3 numbers into the '#ABCDEF' format needed for html
function rgb(aCol)
{
	var red = aCol.r*255;
	var blue = aCol.b*255;
	var green = aCol.g*255;
	if(red>254){red=254;}
	if(blue>254){blue=254;}
	if(green>254){green=254;}
	//  blue=int(blue);
	//  green=int(green);

	var decColor = make_int(red) + 256 * make_int(green) + 65536 * make_int(blue);
	var ret = '#'+int2hex(make_int(red))+int2hex(make_int(green))+int2hex(make_int(blue));
	//  setDiv('debugdiv', "ret: " + ret); 
	return ret; 
}

//Convenience function to update HTML
function setDiv(divName, content)
	{ document.getElementById(divName).innerHTML = content; ;}



// These are the mathematical functions that actually calculate the shapes in the image
//
// They all have the same interface, fn(x,y,z), and they all return true/false to indicate whether or not the point is inside a shape.


function in_mandelbrot (x, y, z) {
	x0 = x-0.3;
	y0 = y;

	x = 0;
	y = 0;

	iteration = 0;
	max_iteration = 1000;

	while ( (x*x + y*y <= (2*2)) && ( iteration < max_iteration) )  {
		xtemp = x*x - y*y + x0;
		y = 2*x*y + y0;

		x = xtemp;

		iteration = iteration + 1;
	}

	if ( iteration == max_iteration ) { return true;}
	return false;
  
}


function in_mandelbulb2 (xx, xy, xz) {
	var x0 = xx;
	var y0 = xy;
	var z0 = xz;

	var mx = 0;
	var my = 0;
	var mz = 0;

	iteration = 0;
	max_iteration = 4;
	n = 8;
	while ( (mx*mx + my*my + mz*mz < 16) && ( iteration < max_iteration) )  {
			// extract polar coordinates
		//{x,y,z}^n = r^n{cos(n*theta)cos(n*phi),sin(n*theta)cos(n*phi),-sin(n*phi)}
		r=Math.sqrt(mx^2+my^2+mz^2);
		theta=n*Math.atan2(my,mx);
		phi=n*Math.asin(mz/r)


		mx = Math.cos(n*theta) * Math.cos(n*phi) + x0;
		my = Math.sin(n*theta) * Math.cos(n*phi) + y0;
		mz = -Math.sin(n*phi) + z0;
		iteration = iteration + 1;
	}
	if ( iteration >= max_iteration ) { return true;}
	return false;
  
}

function in_boxthreads (xx, xy, xz) {
	var x0 = xx;
	var y0 = xy;
	var z0 = xz;

	var mx = x0;
	var my = y0;
	var mz = z0;

	cr= Math.sqrt(mx^2+my^2+mz^2);
	co = Math.acos(my/wr);
	//console.log(co);
	ci = Math.atan2(mx,mz);
	//console.log("consts: " , cr ,co , ci );
	iteration = 0;
	max_iteration = 40;


		// extract polar coordinates
	var wr = Math.sqrt(mx^2+my^2+mz^2);
	var wo = Math.acos(my/wr);
	var wi = Math.atan2(mx,mz);
	while ( (wr < 4) && ( iteration < max_iteration) )  {
		//console.log("w: " , wr , wo, wi);
		// scale and rotate the point
		wr = Math.pow( wr, 8.0 ) + cr;
		wo = wo * 8.0 + co;
		wi = wi * 8.0 + ci;
		iteration = iteration + 1;
	}
	

	if ( iteration >= max_iteration ) { return true;}
	return false;
  
}

function in_mandelquad (xx, xy, xz) {
	var x0 = xx/8;
	var y0 = xy/8;
	var z0 = xz/8;

	var mx = x0;
	var my = y0;
	var mz = z0;


	iteration = 0;
	max_iteration = 40;


		// extract polar coordinates


	while ( (mx*mx+my*my+mz*mz < 16) && ( iteration < max_iteration) )  {
		// scale and rotate the point
		nx = (mx*mx+my*my)*(1-mz*mz/(mx*mx+my*my));
		ny = 2*mx*my*(1-mz*mz/(mx*mx+my*my));
		nz = -2*mz*Math.sqrt(mx*mx+my*my);
		mx=nx +x0;
		my=ny +y0;
		mz=nz +z0;
		iteration = iteration + 1;
	}
	// convert back to cartesian coordinates


	if ( iteration >= max_iteration ) { return true;}
	return false;
  
}



function in_mandelbulb (xx, xy, xz) {
	var x0 = xx;
	var y0 = xy;
	var z0 = xz;

	var mx = x0;
	var my = y0;
	var mz = z0;


	iteration = 0;
	max_iteration = 40;


	// extract polar coordinates
	var wr = Math.sqrt(mx^2+my^2+mz^2);
	var wo = Math.acos(my/wr);
	var wi = Math.atan2(mx,mz);

	var cr= Math.sqrt(mx^2+my^2+mz^2);
	var co = Math.acos(my/wr);
	//console.log(co);
	var ci = Math.atan2(mx,mz);

	while ( (wr < 4) && ( iteration < max_iteration) )  {
		// scale and rotate the point
		wr = Math.pow( wr, 8.0 ) + cr;
		wo = wo * 8.0 + co;
		wi = wi * 8.0 +ci;
		iteration = iteration + 1;
	}
	// convert back to cartesian coordinates
	mx = wr*Math.sin(wo)*Math.sin(wi)+x0;
	my = wr*Math.cos(wo)+y0;
	mz = wr*Math.sin(wo)*Math.cos(wi)+z0;


	if ( iteration >= max_iteration ) { return true;}
	return false;
  
}

function in_mandelbulb1 (nx, ny, nz) {
	var x0 = nx;
	var y0 = ny;
	var z0 = nz;

	var mx = 0;
	var my = 0;
	var mz = 0;

	var iteration = 0;
	var max_iteration = 8;
	var n=8;
	while ( (mx*mx + my*my + mz*mz < 16) && ( iteration < max_iteration) )  {
		var r = Math.sqrt(mx*mx + my*my + mz*mz ) ;
		var theta = Math.atan2(Math.sqrt(mx*mx + my*my) , mz); 
		var phi = Math.atan2(my,mx) ;

		mx = r^(n * Math.sin(theta*n) * Math.cos(phi*n) +x0); 
		my = r^(n * Math.sin(theta*n) * Math.sin(phi*n) +y0);
		mz = r^(n * Math.cos(theta*n) +z0);
		iteration = iteration + 1;
	}

	if ( iteration >= max_iteration ) { return true;}
	return false;
  
}


</script>
<input type=button value=Go onclick="setup();" style="clear:both"/>
<input type=button value=Stop onclick="stop();" style="clear:both"/>
<br style="clear:both"/>
<div style="float:left;vertical-align:top;">
<canvas id="canvasdiv" width="256" height="256" style="float:left;vertical-align:top;display:block" ></canvas> 
</div>
<div style="float:left;vertical-align:top;">
<canvas id="normaldiv" width="256" height="256" style="display:none"></canvas> 
<textarea id=configTextBox rows=13 cols=40 >
[
 new Sphere(1,3,7,2,1,1,0),
 new Boxthreads ( 1,1,0, 0.5, 1,0,1),
 new Cube(0,0,-1,8,0,1,1)
]
</textarea>
</div>
<br style="clear:both"/>
<p>Add new objects to the scene by typing them in the box above.</p>
<h3 id="primitives">Primitives</h3>
<p>These are the shapes available to use in the scene.  Almost all shapes work the same way:</p>
<pre><code>Primitive (x,y,z,scale,Red,Green,Blue)
</code></pre>
<p>Red, Green and Blue must be between 0.0 and 1.0.  So to draw a blue sphere of radius 3, use:</p>
<pre><code>Sphere(0,0,0, 3, 0.0,0.0,1.0)
</code></pre>
<p>The shapes available are:</p>
<ul>
<li>Sphere</li>
<li>BlobCylinder</li>
<li>Cylinder( x1, y1, z1, x2,y2,z2, x3,y3,z3,radius, red, blue, green)</li>
<li>Lsystem</li>
<li>PointCloud</li>
<li>Triangle ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, red, blue, green)</li>
<li>Tetrahedron ( x1, y1, z1, x2,y2,z2, x3,y3,z3,thickness, green, blue, green)</li>
<li>Terrain - everything y&lt;0</li>
<li>Cube - radius is from centre to face of cube.</li>
</ul>
<div id="config" style="display:none"></div>
<p><canvas id="timediv" width="50" height="50" style="display:none"></canvas></p>
<div id="debugdiv" style="display:none" >DebugDivxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</div>

			</article>
			<div class="lightbox-overlay" id="lightbox">
				<span class="lightbox-close" id="lightbox-close">&times;</span>
				<img src="" alt="" id="lightbox-img">
			</div>
			<script>
			(function() {
				var overlay = document.getElementById('lightbox');
				var lightboxImg = document.getElementById('lightbox-img');
				var closeBtn = document.getElementById('lightbox-close');
				
				// Add click handler to all images in the article
				document.querySelectorAll('article img').forEach(function(img) {
					img.addEventListener('click', function(e) {
						e.preventDefault();
						lightboxImg.src = this.src;
						lightboxImg.alt = this.alt;
						overlay.classList.add('active');
					});
				});
				
				// Close on overlay click
				overlay.addEventListener('click', function(e) {
					if (e.target === overlay || e.target === closeBtn) {
						overlay.classList.remove('active');
					}
				});
				
				// Close on escape key
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						overlay.classList.remove('active');
					}
				});
			})();
			</script>
			</html>
			